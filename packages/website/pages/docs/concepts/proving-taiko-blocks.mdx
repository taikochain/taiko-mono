If you don't understand how blocks are proposed and created on Taiko, then read [Creating Taiko blocks](/docs/concepts/creating-taiko-blocks). To recap, you can propose blocks to be included on Taiko by proposing them to the TaikoL1 contract. At the moment the `proposeBlock` transaction is included in an L1 block, the post-L2 state (the Taiko state with the newly added block) can be immediately computed, deterministically.

Now, proving blocks is also an important operation. The purpose of proving blocks is to allow bridges to withdraw state out of the rollup. To rely on some state that happened inside of the rollup, a bridge will want a proof that everything was done correctly.

## The role of a prover

On Taiko you can permissionlessly [run a node](/docs/guides/run-a-taiko-node) as a prover. This means that you can examine the proposed blocks on the TaikoL1 contract, and generate proofs for them. Currently, any prover can create proofs for proposed blocks. This means that the number of "fork choices" has no upper bound, because we don't know what is the correct state transition yet. Only first prover with a valid proof of the correct fork choice (state transition) will receive the reward of TTKO.

## The oracle prover

There is a concept of an oracle prover on Taiko, which will be removed when the circuits are complete and some rollup training wheels have been removed (such as DAO governance and multi-proofs). The oracle prover is a prover that is trusted to provide the correct state transition. If oracle proving is enabled, then the oracle prover will be forced as the first prover for a block and the second will be from a prover. The actual prover (one of you) however will receive the reward of course, this is just a safety mechanism we have in place while the ZK-EVM is still in development.

## The concept of a "verified" block and parallel proving

There are three states that a block can be in on Taiko:
- Proposed
- Valid
- Invalid
- Proved
- Verified

We already know what a proposed block is (must pass at least the block-level intrinsic validity tests to be accepted by the TaikoL1 contract). Next, a proposed block can be valid or invalid, depending on whether it passes the transaction list intrinsic validity test. A block is invalid if it fails the transaction list intrinsic validity test, and this block is not created on Taiko.

Now, a block can be proved, but also further "verified". What's the difference? A block is proved if it has a valid proof which proves a state transition from one state (parent block) to another (current block). However, blocks are proven in parallel by the decentralized provers. So while a block can prove a parent block transitions to the current block, we don't know if the parent block itself has been proven. As you can see, for a block to be "verified", it needs to prove the valid state transition to the current block, but the parent also need to be verified. We assume that the genesis block (which has no parent), is verified. So all the children blocks from genesis to the current block need to have proofs of their state transition for the current block to be "verified".

For the visual learners here is a visualization of the three stages (proposed -> proved -> verified)

### Proposed
![Proposed](/images/diagrams/concepts/proving-taiko-blocks/proposed.png)

### Proved
![Proved](/images/diagrams/concepts/proving-taiko-blocks/proved.png)

### Verified
![Verified](/images/diagrams/concepts/proving-taiko-blocks/verified.png)

