\documentclass[9pt,oneside]{amsart}
%\usepackage{tweaklist}
\usepackage{cancel}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[a4paper,width=170mm,top=18mm,bottom=22mm,includeheadfoot]{geometry}
\usepackage{booktabs}
\usepackage{array}
\usepackage{verbatim}
\usepackage{caption}
\usepackage{float}
\usepackage{pdflscape}
\usepackage{mathtools}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{afterpage}
\usepackage{tikz}
\usepackage[bookmarks=true, unicode=true, pdftitle={Taiko: A TIER-1 ETHEREUM ZK-ROLLUP}, pdfauthor={Taiko Labs},pdfkeywords={Ethereum, White Paper, blockchain,EVM, zkEVM, ZK-Rollup, Layer 2},pdfborder={0 0 0.5 [1 3]}]{hyperref}
%,pagebackref=true

\usepackage{tabu} %requires array.

\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}


\makeatletter
 \newcommand{\linkdest}[1]{\Hy@raisedlink{\hypertarget{#1}{}}}
\makeatother
\usepackage{seqsplit}


\usepackage[english]{babel}
\usepackage[autostyle]{csquotes}
\MakeOuterQuote{"}

\usepackage[final]{microtype} % 
% Default rendering options
\definecolor{pagecolor}{rgb}{0.96,0.96,1}
\def\VersionNumber{0.1.0}
\IfFileExists{Options.tex}{\input{Options.tex}}

\newcommand{\hcancel}[1]{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {#1};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}%


\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\newcommand*\eg{e.g.\@\xspace}
\newcommand*\Eg{e.g.\@\xspace}
\newcommand*\ie{i.e.\@\xspace}
\newcommand{\thedate}{\today}
%\renewcommand{\itemhook}{\setlength{\topsep}{0pt}  \setlength{\itemsep}{0pt}\setlength{\leftmargin}{15pt}}

\title[TAIKO: A Tier-1 Ethereum ZK-Rollup\\ \smaller
\textbf{{DRAFT}}]{TAIKO: A Tier-1 Ethereum ZK-Rollup \\ \smaller \textbf{{DRAFT, \thedate}}}

\author{
  Daniel WANG \texttt{dan@taiko.xyz} \\
  Brecht Devos \texttt{brecht@taiko.xyz}\\
  Someone Else \texttt{youremail@taiko.xyz}
}

\begin{document}

\pagecolor{pagecolor}

\begin{abstract}
\color{brown}
TODO: write abstract here
\color{black}

\end{abstract}

\maketitle

\setlength{\columnsep}{20pt}
\begin{multicols}{2}


\section{Introduction}

\color{brown}
TODO: describe Ethereum scalability challanges?

\color{black}

\section{Previous Work}

\color{brown}
TODO: summarize the current status of Ethereum scabality solutions and ZKRollups. Mentioning Loopring?

\color{black}

\section{Design Principles}

Taiko's ZK-Rollup design follows a few principles:

\begin{enumerate}
\item \textbf{Minimal.} The design shall be simple and focuses only on a barebone ZK-Rollup itself, not its upgradeability, governance, gas-optimization, tokenomics, or any cross-chain bridges.
\item  \textbf{Game theory free.} The design should just work without any assumptions that some parties abide by the protocol rules to avoid being slashed, i.e., there is no Proof-of-Stake of any sort.
\item \textbf{Decentralized.} The design allows for a very high degree of decentralization in terms of block generation (proposing and proving).  There is no single party who can control transaction ordering or block generation. Being sufficiently decentralized also implies that the design shall also allow for slower Zero-Knowledge Proof (ZKP) computation so that parties with overwhelming computation power cannot take over the network. 
\item \textbf{Permissionless.} It's free to join and leave the network without permission granted from a single party of any consortium e.g., super nodes.
\item \textbf{Secure.} The design shall focus on the security aspect of a ZK-Rollup and shall compromise security for anything.
\item \textbf{Real Ether as L2 fees.} We use Ether as L2 transaction fee tokens. 
\end{enumerate}

With these principles, our objective is to design and implement a fully Ethereum-equivalent (tier-1) ZK-Rollup described in Vitalik Buterin's \textit{The different types of ZK-EVMs} article at \url{https://vitalik.ca/general/2022/08/04/zkevm.html}. This literally means Taiko uses the same hashes, state trees, transaction trees, precompiles, and  other in-consensus logic. However, we disable certain EIPs (as shown in Appendix \ref{sec:eips}) in our initial implementation but may be enabled some of them later.

\section{Rollup Contracts}
The Taiko ZK-Rollup protocol has two major smart contracts deployed on L1 and L2, respectively.

\subsection{TaikoL1} Deployed at address $\mathbf{r_{\mathrm{1}}}$ on Ethereum, this contract is used to propose, prove, and finalize blocks. \textit{TaikoL1}  maintains the following rollup state variables:

\begin{description}
\item[nextBlockId] The ID for the next proposed block, formally $R_\mathrm{i}$.
\item[latestFinalizedBlockId] The ID of the latest finalized block, formally $R_\mathrm{f}$.
% \item [numUnprovenBlocks] The number of proposed blocks that have not been proven,  formally $R_\mathrm{n}$.
\item [blockCommits] The mapping from proposed block \textit{commit hashes} to their enclosed L1 blocks' block numbers, formally $R_\mathrm{c}$. If a block's hash is $h$, the commit hash number is $R_\mathrm{c}[h]$.
\item[forkChoices] The mapping from proposed block IDs to their \textit{Fork Choices} , formally $R_\mathrm{f}$. The fork choices for the $i$-th block is $R_\mathrm{f}[i]$. Fork Choices are discussed in detail in section \ref{sec:proving}.
\item[pendingBlocks] The list of pending (unproven) proposed blocks, formally $R_\mathrm{b}$.
\end{description}


\textit{TaikoL1} also maintains a ring buffer for pending blocks. After $K_{\mathrm{MaxPendingBlocks}}$ blocks are proposed, storage will be reused to reduce propose-block gas usage.

\subsection{TaikoL2} Deployed at address $\mathbf{r_{\mathrm{2}}}$ on Taiko, this contracts offers two major functionalities:
\begin{enumerate}
\item Proving a proposed block is invalid on L2 through a valid but throwaway block.
\item Achieving \textit{anchoring}, an important concept in Taiko's design to ensure blocks are valid and cross-chain data exchanges is done right. Anchoring is discussed in section \ref{sec:anchoring}
\end{enumerate}

\section{Blocks and Transactions}

\subsection{Proposing Blocks}
All Taiko blocks are proposed permissionlessly on Ethereum and then converted to actual L2 blocks if they are proven valid, or ignored if they are proven invalid.

\subsubsection{Proposed Block} The proposed block in Taiko is the collection of information (known as the block's \textit{Context}), $C$, and a list of transactions, $L$,  (known as the block \textit{txList}). Formally, we can refer to a proposed block $\dot{B}$:

\begin{equation}
\dot{B} \equiv (\dot{B}_{\mathrm{C}}, \dot{B}_{\mathbf{L}}) \equiv (C, L)
\end{equation}

\subsubsection{Block Context} The block context, $C$, is a tuple of 9 items comprising:


\begin{description}
\item[id] A scalar value equal to the number of already proposed blocks. The genesis block has a number of zero; formally $C_{\mathrm{i}}$.
\item[beneficiary] The 160-bit address to which all fees collected from the corresponding L2 block be transferred; formally $C_{\mathrm{c}}$.
\item[gasLimit] The total gas limit used by the corresponding L2 block; formally $C_{\mathrm{l}}$.
\item[proposedAt] The timestamp when this block is proposed on L1; formally $C_{\mathrm{s}}$.
\item[mixHash] The mixHash value to be used by the corresponding L2 block; formally $C_{\mathrm{m}}$.
\item[extraData] The extraData value to be used by the corresponding L2 block. This must be 32 bytes or fewer; formally $C_{\mathrm{x}}$.
\item[txListHash] The Keccak 256-bit hash (or the KZG polynomial commitment when EIP-4844 is enabled) of this block's txList; formally $C_{\mathrm{t}}$. 
\item[l1Height] The enclosing L1 block's parent block number; formally $C_{\mathrm{a}}$.
\item[l1Hash] The enclosing L1 block's parent block hash; formally $C_{\mathrm{h}}$.
\end{description}

\subsubsection{txList}\label{sec:txlist}
The txList is an RLP-serialised list of proposed L2 transactions. When EIP-4844 is enabled, txLists will be published on L1 as blobs\cite{eip4844} and become inaccessible from the \textit{TaikoL1} contract, thus we demand that \textit{TaikoL1} shall only access a txList to calculate its hash for forward-compatibility, as opposed to reading bytes from it. Such a constraint allows our design outlined in this paper (and current implementations) to remain valid when blobs are used to further reduce data cost.




\subsubsection{Proposed Block Intrinsic Validity}
The proposed block must pass an \textit{Intrinsic Validity} test before it is accepted by the \textit{TaikoL1} contract. 

We are able to define the intrinsic validity function as:

\begin{eqnarray}
V^{b}(\dot{B}) & \equiv &   V^{b}(C,L)  \\
\nonumber & \equiv &   R_\mathbf{i} \le R_\mathbf{f} + K_\mathrm{MaxPendingBlocks}   \quad \wedge \\
\nonumber& & \lVert L \rVert > 0 \quad \wedge \\
\nonumber & & \lVert L \rVert \le K_{\mathrm{TxListMaxBytes}} \quad \wedge \\
\nonumber& & C_{\mathbf{c}} \ne 0   \quad \wedge \\
\nonumber& & C_{\mathbf{i}} = R_\mathbf{i}   \quad \wedge \\
\nonumber& & C_{\mathbf{s}} = \texttt{TIMESTAMP}   \quad \wedge \\
\nonumber& & C_{\mathbf{m}} = \texttt{DIFFICULTY}   \quad \wedge \\
\nonumber& & C_{\mathbf{t}} \ne 0   \quad \wedge \\
\nonumber& & C_{\mathbf{t}} = \texttt{KEC}(L)   \quad \wedge \\
\nonumber& & C_{\mathbf{a}} = \texttt{NUMBER} - 1   \quad \wedge \\
\nonumber& & C_{\mathbf{h}} = \texttt{BLOCKHASH}(C_{\mathbf{a}})   \quad \wedge \\
\nonumber& & R_{\mathbf{c}}[\texttt{KEC}((C_{\mathbf{c}}, C_{\mathbf{t}}))] \ne 0  \quad \wedge \\
\nonumber& & R_{\mathbf{c}}[\texttt{KEC}((C_{\mathbf{c}}, C_{\mathbf{t}}))] \le  \\
\nonumber& &  \texttt{NUMBER}   -  K_{\mathrm{CommitDelayConfirmations}}
\end{eqnarray}

Where $\texttt{KEC}((C_{\mathbf{c}}, C_{\mathbf{t}}))$ is called the block's \textit{Commit Hash}.

After passing the test, the proposed block appends itself to the end of $R_\mathrm{b}$, the pending block list, $R_\mathrm{i}$ will increment by one, and the proposed block's commit hash is deleted.


\subsubsection{Commit Hash} The commit hash is the Keccak 256-bit hash of a proposed block's \textbf{beneficiary} and \textbf{txListHash}. The Taiko ZK-Rollup protocol requires that a block can be proposed only $K_{\mathrm{CommitDelayConfirmations}}$ confirmations after its commit hash has been committed to  \textit{TaikoL1}, which is a measure against MEV attack\cite{mevethfoundation} as  txLists are unencrypted.

Thanks to its commit hash, a block can be proposed by an arbitrary address, i.e., $\mathbf{msg.sender}$ does not matter.

\subsection{Block Validation and Mapping } \label{sec:filtermap}
Taiko L2 node software filters pending proposed blocks using a \textit{txList Intrinsic Validity Function} $V^l$ on each block's txList $L$. If $V^l(L)$ returns \texttt{False}, the proposed block is dropped and ignored; otherwise, the proposed block will map to an actual Taiko L2 block using a \textit{Block Mapping Function} $M(\dot{B})$.

\subsubsection{Validation} The txList intrinsic validity function requires:

\begin{enumerate}
\item The txList is RLP decodable into a list of transactions, and;
\item The number of transactions is no larger than  protocol constant $ K_{\mathrm{BlockMaxTxs}}$, and;
\item The sum of all transaction's gasLimit is no larger than protocol constant $K_{\mathrm{BlockMaxGasLimit}}$, and;
\item Each and every transaction's signature is valid, i.e., it does not recover to the zero address.
\end{enumerate}

Formally, $V^l(L)$ is defined as:


\begin{eqnarray}
V^l(L) & \equiv & \texttt{NOERR}(T \equiv \texttt{RLP}'(L))  \quad \wedge  \\
\nonumber& & \lVert T \rVert \le K_{\mathrm{BlockMaxTxs}} \quad \wedge \\
\nonumber & & (\sum_{j = 0}^{\lVert T \rVert - 1}T[j]_g) \le K_{\mathrm{BlockMaxGasLimit}} \quad \wedge \\
\nonumber & & \prod_{j = 0}^{\lVert T \rVert - 1} (T[j]_g \ge K_{\mathrm{TxMinGasLimit}})\quad \wedge \\
\nonumber & & \prod_{j = 0}^{\lVert T \rVert - 1} (\texttt{NOERR}(\texttt{ECRECOVER}(T[j]) \ne 0) )
\end{eqnarray}

Where $\texttt{NOERR}(S)$ is a catch-error function that returns \texttt{False} if statement $S$ throws an error; $\texttt{RLP}'$ is the RLP decoding function;  $T_g$ is a transaction's gasLimit; 


It is important to realize that the txList intrinsic validity function cannot be called on L1 as txLists are not accessible to Ethereum EVM on the byte level, as explained in \ref{sec:txlist}, unless the same txLists are submitted again to L1 in the form of transaction calldata, which will be more expensive than blobs and should be avoided after EIP-4844.

\subsubsection{Mapping}

Each proposed block that both $V^b(\dot{B})$ and $V^l(\dot{B}_L)$ return $\texttt{True}$ maps to an actual Taiko L2 block. Taiko blocks have the same structure as Ethereum blocks as defined in the Ethereum Yellow Paper\cite{ethyellowpaper}:

\begin{eqnarray}
B_H & \equiv & (H_p, H_o, H_c, H_r, H_t, H_e, H_b, H_d, \\
\nonumber & & H_i, H_l,H_g, H_s, H_x, H_m, H_n) \\
B_U  & \equiv & [] \\
B & \equiv & (B_H, B_T, B_U)
\end{eqnarray}

Where $H_p$ is the block's parentHash, $H_o$ is the ommersHash, $H_c$ is the beneficiary, $H_r$ is the stateRoot, $H_t$ is the transactionsRoot, $H_e$ is the receiptsRoot, $H_b$ is the logsBloom, $H_d$ is the difficulty, $H_i$ is the block number, $H_l$ is the gasLimit, $H_g$ is the gasUsed, $H_s$ is the timestamp, $H_x$ is the extraData, $H_m$ is the mixHash, $H_n$ is the nonce; $B_T$ a series of the transactions; and $B_U$ is a list of ommer block headers but is always empty for Taiko because there is no Proof-of-Work.

Transactions in Taiko also conform to the same Ethereum standard defined by the Ethereum Yellow Paper. But initially, only type 0 (legacy)  transactions are supported as EIP-1559 is disabled on Taiko initially (but may be enabled in a future version).

A proposed block can only be mapped to a Taiko block in a \textit{Mapping Context} which is the world state $\boldsymbol{\sigma}$:

$$\boldsymbol{\sigma} \equiv (\boldsymbol{\delta}, h[1..256], d, i, \theta)$$

Where $\boldsymbol{\delta}$ is the trie, $h[1...256]$ are the most recent 256 ancestor block hashes, $d$ is Taiko's chain ID, $\theta$ is the anchor transaction, and $i$ is the block number.

Now we can define the block mapping function $M$ as:

\begin{eqnarray}
M(B) & \equiv & M(H, T, U), \\
\nonumber & \equiv &  M(\boldsymbol{\delta}, h[1..256], {d}, i, \theta, \dot{B}, )  \\
\nonumber & \equiv & M(\boldsymbol{\delta}, h[1..256], {d}, i, \theta, C, L)
\end{eqnarray}


such that:

\begin{eqnarray}
& & \texttt{CHAINID}  = \quad \wedge \\
\nonumber& & \texttt{NUMBER} = {i} \quad \wedge \\
\nonumber& & U = [] \quad \wedge \\
\nonumber& & T =  \theta::V^t(\texttt{RLP}'(L)) \quad \wedge  \\
\nonumber& & H_p =  h(1) \quad \wedge \\
\nonumber& & H_o =   K_{\mathrm{EmptyOmersHash}} \quad \wedge \\
\nonumber& & H_c =   C_c \quad \wedge \\
\nonumber& & H_d =   0 \quad \wedge \\
\nonumber& & H_i =   i \quad \wedge \\
\nonumber& & H_l =   C_l + K_{\mathrm{AnchorTxGasLimit}} \quad \wedge \\
\nonumber& & H_s =   C_s \quad \wedge \\
\nonumber& & H_x =   C_x \quad \wedge \\
\nonumber& & H_m =   C_m \quad \wedge \\
\nonumber& & (H_r, H_t, H_e, H_l, H_g) =   \Pi(\boldsymbol{\sigma}, (T_0, T_1, ...))
\end{eqnarray}

Where $\Pi$ is the block transition function; $::$ is the list concatenation operator; $V^t$ is the \textit{"initial tests of intrinsic validity"} function defined in the Transaction Execution section of the Ethereum Yellow Paper. To avoid confusion, in this document, we call $V^t$ the \textit{Contextual Validity } function.

$V^t(\texttt{RLP}'(L))$ yields a list of transactions that pass the tests; transactions that don't pass the tests are simply ignored thus will not become part of the L2 block. Note that it is possible and fine that $V^t(\texttt{RLP}'(L))$ returns an empty list.


\subsection{Anchor Transaction} \label{sec:anchoring}

The anchor transaction is always the first one in a Taiko L2 block to perform certain duties:

\begin{enumerate}
\item Persisting the values of $i$, $d$, $h[1]$ -- the parent block hash -- to the trie (for the next block to use), which enables $i$, $d$, $h[1]$ to be also covered by  zkEVM's storage proof.   With anchoring, the block mapping function $M$  can be simplified:

\begin{eqnarray}
B & \equiv & (H, T, U), \\
\nonumber & \equiv &  M(\boldsymbol{\delta}, \theta, \dot{B}, )  \\
\nonumber & \equiv & M(\boldsymbol{\delta},  \theta, C, L)
\end{eqnarray}

\item Comparing $i$, $d$, $h[2..256])$ with values persisted by previous blocks. The anchor transaction will throw an exception if any comparison fails, which will make this block unprovable on L1.
\item Inserting l1Height $C_a$ and l1Hash $C_h$ into a mapping structure on L2 as a key-value pair. These L1 block hashes can be used by bridges to validate cross-chain messages.
\end{enumerate}

We can add additional duties to anchor transaction implementation to enrich Taiko's functionalities without requesting changes in Taiko's zkEVM subsystem.

\subsubsection{Construction of Anchor Transactions} All anchor transactions are signed by a goldfinger address with a revealed private key. 

Anchor transactions are constructed by Taiko L2 nodes as follows:

\begin{eqnarray}
& & \theta_x = 0 \quad \wedge \\
\nonumber& & \theta_n = \boldsymbol{\delta}[K_{\mathrm{GoldfingerAddress}}]_n + 1 \quad \wedge \\
\nonumber& & \theta_p = 0 \quad \wedge \\
\nonumber& & \theta_g = K_{\mathrm{AnchorTxGasLimit}} \quad \wedge \\
\nonumber& & \theta_t = K_{\mathrm{GoldfingerAddress}} \quad \wedge  \\
\nonumber& & \theta_v = 0 \quad \wedge  \\
\nonumber& & \theta_d = K_{\mathrm{AnchorTxSelector}}::C_a::C_h \quad \wedge  \\
\nonumber& & (\theta_r,\boldsymbol{\delta}_s) = \texttt{K1ECDSA}(\boldsymbol{\delta}, K_{\mathrm{GoldfingerPrivateKey}})
\end{eqnarray}

Where \texttt{K1ECDSA} is the ECDSA\cite{ecdsa} signing function with the internal variable $k$ set to $1$, which guarantees the transaction's signature to only depend on the transaction itself and therefore is deterministic\cite{ecdsak}.

According to ECDSA's spec, when $k$ is $1$, $\theta_r$ must equal $\mathrm{G_x}$, the value of the x-coordinate of the base point on the SECP-256k1 curve. The \textit{TaikoL1} contract verifies this assertion.


\subsection{Proving Blocks} \label{sec:proving}

Proving a block creates a Fork Choice which is an attestation that the block in question transits a prover-selected parent block's corresponding world state to a new world state. A Fork Choice is a tuple of 3 elements:

\begin{equation}
E \equiv (H_p, H_h, [(a_1, p^{z}_1, p^{m}_1),...])
\end{equation}

where $H_p$ is the block's parent hash, $H_h \equiv \texttt{KEC}(\texttt{RLP}(H))$ is the hash of the proposed block after being mapped in L2, and $(a_i, p^{z}_i, p^{m}_i)$ are the $i$-th prover's address and the proofs. $p^{z}$ is a ZKP from zkEVM that proves the state transition from the parent hash is correct, and $p^{m}$ is a Merkle proof that proves the anchor transaction is valid and is the first transaction of the block in L2.

Taiko allows up to $K_{\mathrm{MaxProofsPerForkChoice}}$ provers per fork choice but sets no limit on the number of fork choices.

\subsubsection{Proving Invalid Blocks} \label{sec:provinginvaid}

If a block fails to pass the Intrinsic Validity Function $V^l$, the block can be proven invalid using a valid throw-away L2 block $\dot{B}$ whose first transaction is a TaikoL2 $invalidateBlock$ transaction with the target block's txList as the sole input. $invalidateBlock$ will emit an $BlockInvalidated$ event with the target block's txList hash as a topic. On L1, we only need to verify that:

\begin{enumerate}
\item The throw-away block is $\dot{B}$ valid.
\item The first event emitted in the block is $BlockInvalidated$ event with the expected txList hash. 
\end{enumerate}

The Fork Choice for an invalid block is:

\begin{equation}
E \equiv (H_p, H_h \equiv K_{\mathrm{BlockDeadEndHash}}, [(a_1, p^{z}_1, p^{m}_1),...])
\end{equation}

Where $K_{\mathrm{BlockDeadEndHash}}$ is a special value marking this Fork Choice is for an invalid block; $p^{z}$ and  $p^{m}$ prove the throw-away block is invalid, not the target proposed block.

It's very important to notice that throw-away blocks are not mapped to L2 and are never part of the Taiko chain.

\subsection{Finalizing Blocks}\label{sec:finalizing}

Assuming the $j$-th block is the latest finalized valid block. The $i$-th block ($i$ > $j$) can be finalized if 1) the $(i-1)$-th block has been finalized, and 2) the $i$-th block has a Fork Choice $E$ whose parent block hash $E(H_p)$ equals the the $j$-th block's hash.

If $H_h$ equals $K_{\mathrm{BlockDeadEndHash}}$, the $i$-th block is marked as finalized, $j$ is not updated; otherwise,  $j$ changes to $i$ so now the $i$-th block becomes the latest finalized valid block. Obviously, on L1, Taiko's canonical chain is a subset of all proposed blocks linked through Fork Choices; on L2, Taiko's canonical chain is a subset of all proposed blocks filtered by the Intrinsic Validity Function.

\subsection{Deterministic Blocks}
To enable parallel ZKP computation, all blocks, once proposed on L1, must have deterministic state transitions on L2. Our design ensures all potential public and private inputs are verified on L1 directly or indirectly to achieve deterministic block transitions.

\section{Assumptions on zkEVM}

What a ZKP can and cannot prove is critical to a zkRollup's protocol design. Taiko's current protocol design is fundamentally different from the one we had in Q2 2022, mainly because we adopted a new set of ZKP assumptions that will be outlined in this section.


\subsection{ZKP Computation} The ZKP computation function $\hat{C}$ for address $a$ is defined as:


\begin{equation}
    p^z(a) \equiv \hat{C}(a, H,\theta, L, \Delta(\theta::V^t(L)) )
\end{equation}
Where $H$ is the block header, $\theta$ is the anchor transaction, $L$ is the block's RLP-encoded txList, and $\Delta$ is the EVM trace logs generated from running $\theta$ and all transactions in $L$ that the contextual validity $V^t$ function returns \texttt{True}.

We assume:
\begin{enumerate}
\item zkEVM always generates the same ZKP if all inputs are fixed, and;
\item zkEVM always generates different ZKPs if a single input is changed.
\item zkEVM is unable to generate a ZKP if the txList fails to pass the block intrinsic validity test or any transaction (including the anchor transaction) fails to pass the transaction contextual validity test.
\item zkEVM also disabled the same set of Ethereum upgrades listed in Appendix \ref{sec:eips}
\end{enumerate}


It is critical that the prover address $a$ is an input variable for the equation; otherwise, ZKPs can be stolen while their enclosing transactions are pending in Ethereum's mempool.

\subsection{ZKP Verification} To verify a ZKP $p^z$ generated by address $a$ for the $i$-th block, we have the verification function defined as:

\begin{equation}
    \hat{V}(p^z, a, h[i], \texttt{KEC}(L), \kappa)
\end{equation}
Where $h[i]$ is the block's hash, $\kappa$ is  zkEVM's verification key.

\section{Cross-Chain Communication}
Taiko enables third parties to develop cross-chain bridges for handling cross-chain communication. The Taiko protocol only ensures some block headers are synchronized between Ethereum and Taiko so bridges can utilize Merkle proofs to verify the validity of cross-chain messages.

On Ethereum, the \textit{TaikoL1} contract persists the height and hash of the latest block finalized in a batch; on Taiko, the \textit{TaikoL2} contract uses the anchor function to persist the height and hash of the Ethereum block where the current L2 block is finalized. These cross-chain exchanged block headers are available as solidity mapping objects for bridges to query.

\subsection{Ether on L2}
Taiko ensures L2 Ether and L1 Ether are always 1-to-1 convertible. $2^128$ Ether is minted to a special vault contract called \textit{EthVault} (and a few EOAs) in the genesis block. When a user deposits Ether to L2, the same amount of Ether will be transferred from \textit{EthVault} to the user on L2; when a user withdraws some Ether from L2, Ether on L2 must be transferred back to \textit{EthVault}. Compared to ERC20 tokens, Ether on L2 is never burnt.

Some small amounts of Ether are also minted to a few EOAs to bootstrap the L2 network, otherwise; nobody will be able to transact.

\end{multicols}

\bibliographystyle{IEEEtran}
\bibliography{main}

\appendix

\section{Terminology} \label{ch:Terminology}

\begin{description}
\item[Anchor Transaction] The first transaction in every Taiko L2 block to perform data validation and L1-to-L2 communication.


\item[Fork Choice] A data structure to capture a block's proving result based on a prover-chosen parent block.

\item[Goldfinger Address] An address with a revealed private key to transact all anchor transactions.

\item[zkEVM] A project that aims to define a validity snark proof for Ethereum transactions. zkEVM is initiated and led by 
Privacy \& Scaling Explorations (formerly known as AppliedZKP). \\ 
\url{https://github.com/privacy-scaling-explorations}.
\end{description}


\section{Ethereum Upgrades on Taiko}\label{sec:eips}

\begin{tabu}{l r }
\toprule
Name & Status \\
\midrule
EIP-606 -- Hardfork Meta: Homestead & \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad  Enabled \\
EIP-779 -- Hardfork Meta: DAO Fork & Disabled \\
EIP-150 - Gas cost changes for IO-heavy operations & Enabled \\
EIP-155 -- Simple replay attack protection &  Enabled \\
EIP-158 -- State clearing) & Enabled \\
EIP-609 -- Hardfork Meta: Byzantium & Enabled \\
EIP-1013 -- Hardfork Meta: Constantinople & Enabled \\
EIP-1716 -- Hardfork Meta: Petersburg & Enabled \\
EIP-1679 -- Hardfork Meta: Istanbul & Enabled \\
EIP-2387 -- Hardfork Meta: Muir Glacier & Disabled \\
Berlin Network Upgrade & Enabled \\
London Network Upgrade & Disabled \\
Arrow Glacier Network Upgrade & Disabled \\
EIP-3675 -- Upgrade consensus to Proof-of-Stake & Enabled \\
Shanghai Network Upgrade & Disabled (future) \\
Cancun Network Upgrade & Disabled (future)  \\
\bottomrule
\end{tabu}



\section{Protocol Constants}\label{sec:constants1}

\begin{tabu}{l r l}
\toprule
Name & Value & Description \\
\midrule
$K_{\mathrm{ChainID}}$ & 1337 & Taiko's chain ID. \\
$K_{\mathrm{MaxPendingBlocks}}$ & 2048 & The maximum number of pending blocks. \\
$K_{\mathrm{MaxFinalizationsPerTx}}$ & 5 & The number of proven blocks that can be finalized when a new block is\\
& & proposed or a pending block is proven. \\
$K_{\mathrm{CommitDelayConfirmations}}$ & 4 & The number of confirmations to wait for before a block can be proposed\\
& &  after its commit-hash has been written on Ethereum.\\
$K_{\mathrm{MaxProofsPerForkChoice}}$ & 5 & The maximum number of proofs per fork choice. \\
$K_{\mathrm{BlockMaxGasLimit}}$ & 5000000 & A Taiko block's max gas limit besides $K_{\mathrm{AnchorTxGasLimit}}$.  \\
$K_{\mathrm{BlockMaxTxs}}$ & 20 & The maximum number of transactions in a Taiko block besides the anchor\\
& & transaction. \\
$K_{\mathrm{BlockDeadEndHash}}$ & 0x1 & A special value to mark blocks proven invalid. \\
$K_{\mathrm{TxListMaxBytes}}$ & 10240 & A txList's maximum number of bytes. \\
$K_{\mathrm{TxMinGasLimit}}$ & 21000 & A transaction's minimum gas limit. \\
$K_{\mathrm{AnchorTxGasLimit}}$ & 100000 & Anchor transaction's fixed gas limit. \\
\bottomrule
\end{tabu}

\begin{tabu}{l l}
\toprule
Name &  \quad \quad Value \\
\midrule
$K_{\mathrm{AnchorTxSelector}}$ &  \quad \quad 0xa0ca \\
$K_{\mathrm{GoldfingerAddress}}$ &  \quad \quad 0x0000777735367b36bC9B61C50022d9D0700dB4Ec  \\
$K_{\mathrm{GoldfingerPrivateKey}}$ & \quad \quad 0x92954368afd3caa1f3ce3ead0069c1af414054aefe1ef9aeacc1bf426222ce38 \\
$K_{\mathrm{InvalidateBlockLogTopic}}$ & \quad \quad 0x64b299ff9f8ba674288abb53380419048a4271dda03b837ecba6b40e6ddea4a2 \\
$K_{\mathrm{EmptyOmersHash}}$ & \quad \quad 0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347   \quad \quad \quad \quad \\
\bottomrule
\end{tabu}

\end{document}