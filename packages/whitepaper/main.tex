\documentclass[9pt,oneside]{amsart}
%\usepackage{tweaklist}
\usepackage{cancel}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[a4paper,width=170mm,top=18mm,bottom=22mm,includeheadfoot]{geometry}
\usepackage{booktabs}
\usepackage{array}
\usepackage{verbatim}
\usepackage{caption}
\usepackage{natbib}
\usepackage{float}
\usepackage{pdflscape}
\usepackage{mathtools}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{afterpage}
\usepackage{tikz}
\usepackage[bookmarks=true, unicode=true, pdftitle={Taiko: A TIER-1 ETHEREUM ZK-ROLLUP}, pdfauthor={Taiko Labs},pdfkeywords={Ethereum, White Paper, blockchain,EVM, zkEVM, ZK-Rollup, Layer 2},pdfborder={0 0 0.5 [1 3]}]{hyperref}
%,pagebackref=true

\usepackage{tabu} %requires array.

%This should be the last package before \input{Version.tex}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
% "hyperref loads the url package internally. Use \PassOptionsToPackage{hyphens}{url}\usepackage{hyperref} to pass the option to the url package when it is loaded by hyperref. This avoids any package option clashes." Source: <https://tex.stackexchange.com/questions/3033/forcing-linebreaks-in-url/3034#comment44478_3034>.
% Note also this: "If the \PassOptionsToPackage{hyphens}{url} approach does not work, maybe it's "because you're trying to load the url package with a specific option, but it's being loaded by one of your packages before that with a different set of options. Try loading the url package earlier than the package that requires it. If it's loaded by the document class, try using \RequirePackage[hyphens]{url} before the document class." Source: <https://tex.stackexchange.com/questions/3033/forcing-linebreaks-in-url/3034#comment555944_3034>.
% For more information on using the hyperref package, refer to e.g. https://en.wikibooks.org/w/index.php?title=LaTeX/Hyperlinks&stable=0#Hyperlink_and_Hypertarget.

\makeatletter
 \newcommand{\linkdest}[1]{\Hy@raisedlink{\hypertarget{#1}{}}}
\makeatother
\usepackage{seqsplit}

% For formatting
%\usepackage{underscore}
%\usepackage{lipsum} % to generate filler text for testing of document rendering
\usepackage[english]{babel}
\usepackage[autostyle]{csquotes}
\MakeOuterQuote{"}

\usepackage[final]{microtype} % https://tex.stackexchange.com/questions/75140/is-it-possible-to-make-latex-mark-overfull-boxes-in-the-output#comment382776_75142


% Default rendering options
\definecolor{pagecolor}{rgb}{0.96,0.96,1}
\def\VersionNumber{0.1.0}
\IfFileExists{Options.tex}{\input{Options.tex}}

\newcommand{\hcancel}[1]{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {#1};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}%


\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\newcommand*\eg{e.g.\@\xspace}
\newcommand*\Eg{e.g.\@\xspace}
\newcommand*\ie{i.e.\@\xspace}
\newcommand{\thedate}{\today}
%\renewcommand{\itemhook}{\setlength{\topsep}{0pt}  \setlength{\itemsep}{0pt}\setlength{\leftmargin}{15pt}}

\title[TAIKO: A Tier-1 Ethereum ZK-Rollup\\ \smaller \textbf{{DRAFT \VersionNumber}}]{TAIKO: A Tier-1 Ethereum ZK-Rollup \\ \smaller \textbf{{DRAFT \VersionNumber, \thedate}}}

\author{
  Daniel WANG\\
  \texttt{dan@taiko.xyz}
  \and
  Brecht Devos\\
  \texttt{brecht@taiko.xyz}
}
\begin{document}

\pagecolor{pagecolor}

\begin{abstract}
TBD
\end{abstract}

\maketitle

\setlength{\columnsep}{20pt}
\begin{multicols}{2}


\section{Introduction}

TBD

\subsection{Design Principles}

TBD

\section{Rollup Contracts}
The Taiko ZK-Rollup protocol has two major smart contracts deployed on L1 and L2, respectively.

\subsection{TaikoL1} Deployed at address $\mathbf{r_{\mathrm{1}}}$ on Ethereum, this contract is used to propose, prove, and finalize blocks. TaikoL1  maintains the following rollup state variables:

\begin{description}
\item[nextBlockId] The ID for the next proposed block, formally $R_\mathrm{i}$.
\item[lastFinalizedBlockId] The ID of the last finalized block, formally $R_\mathrm{f}$.
% \item [numUnprovenBlocks] The number of proposed blocks that have not been proven,  formally $R_\mathrm{n}$.
\item [blockCommits] The mapping from proposed block \textit{commit hashes} to their enclosed L1 blocks' block numbers, formally $R_\mathrm{c}$. If a block's hash is $h$, the commit hash number is $R_\mathrm{c}[h]$.
\item[forkChoices] The mapping from proposed block IDs to their \textit{Fork Choices} , formally $R_\mathrm{f}$. The fork choices for the $i$-th block is $R_\mathrm{f}[i]$. Fork choices is discussed in detail in section \ref{sec:forkchoices}.
\item[pendingBlocks] The list of pending (unproven) proposed blocks, formally $R_\mathrm{b}$.
\end{description}



\subsection{TaikoL2} Deployed at address $\mathbf{r_{\mathrm{2}}}$ on Taiko, this contracts offers two major functionalities:
\begin{enumerate}
\item Proving a proposed block is invalid on L2 through a valid but throwaway block.
\item Achieving \textit{anchoring}, an important concept in Taiko's design to ensure blocks are valid and cross-layer data exchange are done right. Anchoring is discussed in section \ref{sec:anchoring}
\end{enumerate}

\section{Blocks and Transactions}

\subsection{Proposing Blocks}
All Taiko blocks are proposed permissionlessly on Ethereum then converted to actual L2 blocks if they are proven valid, or ignored if they are proven invalid.

\subsubsection{Proposed Block} The proposed block in Taiko is the collection of information (known as the block's \textit{context}), $C$, and a list of transactions, $L$,  (known as the block \textit{txList}). Formally, we can refer to a proposed block $\bar{B}$:

\begin{equation}
\bar{B} \equiv (\bar{B}_{\mathrm{C}}, \bar{B}_{\mathbf{L}})
\end{equation}

\subsubsection{Block Context} The block context, $C$, is a tuple of 9 items comprising:


\begin{description}
\item[id] A scalar value equal to the number of already proposed blocks.The genesis block has a number of zero; formally $C_{\mathrm{i}}$.
\item[beneficiary] The 160-bit address to which all fees collected from the corresponding L2 block be transferred; formally $C_{\mathrm{c}}$.
\item[gasLimit] The total gas limit used by the corresponding L2 block; formally $C_{\mathrm{l}}$.
\item[proposedAt] The timestamp when this block is proposed on L1; formally $C_{\mathrm{s}}$.
\item[mixHash] The mixHash value to be used by the corresponding L2 block; formally $C_{\mathrm{m}}$.
\item[extraData] The extraData value to be used by the corresponding L2 block;. This must be 32 bytes or fewer; formally $C_{\mathrm{x}}$.
\item[txListHash] The Keccak 256-bit hash (or the KZG polynomial commitment when EIP-4844 is enabled) of this block's txList; formally $C_{\mathrm{t}}$. 
\item[anchorHeight] The enclosing L1 block's parent block number; formally $C_{\mathrm{a}}$.
\item[anchorHash] The enclosing L1 block's parent block hash; formally $C_{\mathrm{h}}$.
\end{description}

\subsubsection{txList}\label{sec:txlist}
The txList is a RLP-serialised list of proposed L2 transactions. When EIP-4844 is enabled, txLists will be published on L1 as blobs and become inaccessible from the TaikoL1 contract, thus we demand that TaikoL1 shall only access a txList to calculate its hash, as opposed to read bytes from it. Such a constrain allows our design outlined in this paper (and current implementations) to remain valid when blobs are used to further reduce data cost.




\subsubsection{Proposed Block Intrinsic Validity}
The proposed block must pass an \textit{intrinsic validity} test before it is accepted by the TaikoL1 contract. 

We are able to define the intrinsic validity function $V(\bar{B})$:

\begin{eqnarray}
V(\bar{B}[i]) & \equiv &   V(C,L)  \\
\nonumber & \equiv &   R_\mathbf{i} \le R_\mathbf{f} + K_\mathrm{MaxPendingBlocks}   \quad \wedge \\
\nonumber& & \lVert L \rVert > 0 \quad \wedge \\
\nonumber & & \lVert L \rVert \le K_{\mathrm{TxListMaxBytes}} \quad \wedge \\
\nonumber& & C_{\mathbf{c}} \ne 0   \quad \wedge \\
\nonumber& & C_{\mathbf{i}} = R_\mathbf{i}   \quad \wedge \\
\nonumber& & C_{\mathbf{s}} = \texttt{TIMESTAMP}   \quad \wedge \\
\nonumber& & C_{\mathbf{m}} = \texttt{DIFFICULTY}   \quad \wedge \\
\nonumber& & C_{\mathbf{t}} \ne 0   \quad \wedge \\
\nonumber& & C_{\mathbf{t}} = \texttt{KEC}(L)   \quad \wedge \\
\nonumber& & C_{\mathbf{a}} = \texttt{NUMBER} - 1   \quad \wedge \\
\nonumber& & C_{\mathbf{h}} = \texttt{BLOCKHASH}(C_{\mathbf{a}})   \quad \wedge \\
\nonumber& & R_{\mathbf{c}}[\texttt{KEC}((C_{\mathbf{c}}, C_{\mathbf{t}}))] \ne 0  \quad \wedge \\
\nonumber& & R_{\mathbf{c}}[\texttt{KEC}((C_{\mathbf{c}}, C_{\mathbf{t}}))] \le  \\
\nonumber& &  \texttt{NUMBER}   -  K_{\mathrm{CommitDelayConfirmations}}
\end{eqnarray}

Where $\texttt{KEC}((C_{\mathbf{c}}, C_{\mathbf{t}}))$ is called the block's \textit{commit hash}.

After passing the test, the proposed block appends itself to the end of $R_\mathrm{b}$, the pending block list; $R_\mathrm{i}$ will increment by one; and its commit hash is deleted.


\subsubsection{Commit Hash} The commit hash is the Keccak 256-bit hash of a proposed block's \textbf{beneficiary} and \textbf{txListHash}. The Taiko ZK-Rollup protocol requires that a block can be proposed only $K_{\mathrm{CommitDelayConfirmations}}$ confirmations after its commit hash has been committed to  {TaikoL1}, which is a measure against MEV attack \cite{mevethfoundation} as block txLists are unencrypted.

Thanks to its commit hash, a block can be proposed by an arbitrary address, i.e., $\mathbf{msg.sender}$ dose not matter.

\subsection{Block Validation and Mapping } \label{sec:filtermap}
Taiko L2 node software filters pending proposed blocks using the \textit{txList Intrinsic Validity Function} $V^l$ on each block's txList $L$. If $V^l(L)$ returns \texttt{False}, the proposed block is dropped and ignored; otherwise, the proposed block will map to an actual Taiko L2 block using a \textit{Block Mapping Function} $M(\hat{B})$.

\subsubsection{Validation} The txList Intrinsic Validity Function requires:

\begin{enumerate}
\item The txList is RLP decodable into a list of transactions, and;
\item The number of transactions is no larger than  protocol constant $ K_{\mathrm{BlockMaxTxs}}$, and;
\item The sum of all transaction's gasLimit is no larger than protocol constant $K_{\mathrm{BlockMaxGasLimit}}$, and;
\item Each and every transaction's signature is valid, i.e., it does not recover to the zero address.
\end{enumerate}

Formally, $V^l(L)$ is defined as:


\begin{eqnarray}
V^l(L) & \equiv & \texttt{NOERR}(T \equiv \texttt{RLP}'(L))  \quad \wedge  \\
\nonumber& & \lVert T \rVert \le K_{\mathrm{BlockMaxTxs}} \quad \wedge \\
\nonumber & & (\sum_{j = 0}^{\lVert T \rVert - 1}T[j]_g) \le K_{\mathrm{BlockMaxGasLimit}} \quad \wedge \\
\nonumber & & \prod_{j = 0}^{\lVert T \rVert - 1} (T[j]_g \ge K_{\mathrm{TxMinGasLimit}})\quad \wedge \\
\nonumber & & \prod_{j = 0}^{\lVert T \rVert - 1} (\texttt{NOERR}(\texttt{ECRECOVER}(T[j]) \ne 0) )
\end{eqnarray}

Where $\texttt{NOERR(S)}$ is a catch-error function that returns \texttt{False} if statement $S$ throws an error; $\texttt{RLP}'$ is the RLP decode function;  $T_g$ represents a transaction's \textbf{gasLimit}; 





It is important to realize that the txList Intrinsic Validity Function cannot be called on L1 as txLists are not accessible to Ethereum EVM on the byte level, as explained in \ref{sec:txlist}, unless the same txLists are submitted again to L1 in the form of transaction calldata, which will be more expensive than blobs and should be avoided after EIP-4844\cite{eip4844}.

\subsubsection{Mapping}

Each proposed block that $V^l(\bar{B}_L)$ returns $\texttt{True}$ maps to an actual Taiko L2 block. Taiko blocks have the same structure as Ethereum blocks as defined in in the Ethereum Yellow Paper \cite{ethyellowpaper}:

\begin{eqnarray}
B_H & \equiv & (H_p, H_o, H_c, H_r, H_t, H_e, H_b, H_d, \\
\nonumber & & H_i, H_l,H_g, H_s, H_x, H_m, H_n) \\
B_U  & \equiv & [] \\
B & \equiv & (B_H, B_T, B_U)
\end{eqnarray}

Where $H_p$ is the block's \textbf{parentHash}, $H_o$ is the \textbf{EmptyOmersHash}, $H_c$ is the \textbf{beneficiary}, $H_r$ is the \textbf{stateRoot}, $H_t$ is the \textbf{transactionsRoot}, $H_e$ is the \textbf{receiptsRoot}, $H_b$ is the \textbf{logsBloom}, $H_d$ is the \textbf{difficulty}, $H_i$ is the block \textbf{number}, $H_l$ is the \textbf{gasLimit}, $H_g$ is the \textbf{gasUsed}, $H_s$ is the \textbf{timestamp}, $H_x$ is the \textbf{extraData}, $H_m$ is the \textbf{mixHash}, $H_n$ is the \textbf{nonce}; $B_T$ a series of the transactions; and $B_U$ is a list of ommer block headers but is always empty for Taiko because there is no Proof-of-Work.

Transactions in Taiko also conform to the same Ethereum standard defined by the Ethereum Yellow Paper. But currently only type 0 (legacy) and type 1 transactions are supported as EIP-1559 is disabled on Taiko initially (but may be enabled in a future version).

A proposed block can only be mapped to a Taiko block in a \textit{mapping context} which is the world state $\boldsymbol{\sigma}$:

$$\boldsymbol{\sigma} \equiv (\boldsymbol{\delta}, h[1..256], d, i, \boldsymbol{\theta})$$

Where $\boldsymbol{\delta}$ is the trie, $h[1...256]$ are the most recent 256 ancestor block hashes; and $d$ is Taiko's chain ID, $\boldsymbol{\theta}$ is the anchor transaction, and $i$ is the block number.

Now we can define the block mapping function $M$ as:

\begin{eqnarray}
B & \equiv & (H, T, U), \\
\nonumber & \equiv &  M(\boldsymbol{\delta}, h[1..256], {d}, i, \boldsymbol{\theta}, \bar{B}, )  \\
\nonumber & \equiv & M(\boldsymbol{\delta}, h[1..256], {d}, i, \boldsymbol{\theta}, C, L)
\end{eqnarray}


such that:

\begin{eqnarray}
& & \texttt{CHAINID}  = \quad \wedge \\
\nonumber& & \texttt{NUMBER} = {i} \quad \wedge \\
\nonumber& & U = [] \quad \wedge \\
\nonumber& & T =  \boldsymbol{\theta}::F(\texttt{RLP}'(L), V^t) \quad \wedge  \\
\nonumber& & H_p =  h(1) \quad \wedge \\
\nonumber& & H_o =   K_{\mathrm{EmptyOmersHash}} \quad \wedge \\
\nonumber& & H_c =   C_c \quad \wedge \\
\nonumber& & H_d =   0 \quad \wedge \\
\nonumber& & H_i =   i \quad \wedge \\
\nonumber& & H_l =   C_l + K_{\mathrm{AnchorTxGasLimit}} \quad \wedge \\
\nonumber& & H_s =   C_s \quad \wedge \\
\nonumber& & H_x =   C_x \quad \wedge \\
\nonumber& & H_m =   C_m \quad \wedge \\
\nonumber& & (H_r, H_t, H_e, H_l, H_g) =   \Pi(\boldsymbol{\sigma}, (T_0, T_1, ...))
\end{eqnarray}

Where $\Pi$ is the block transition function; $::$ is the list concatenation operator; $V^t$ is the \textit{transaction intrinsic validity test function} defined in the Transaction Execution section of the Ethereum Yellow Paper. Transactions in the txList that fail the test will be ignored thus won't make into the L2 block.


\subsection{Anchoring} \label{sec:anchoring}

The anchor transaction is always the first one in a Taiko L2 block to perform certain duties:

\begin{enumerate}
\item Persisting the values of $i$, $d$, $h[1]$ -- the parent block hash -- to the trie (for the next block to use), which enables $i$, $d$, $h[1]$ to be also covered by the zkEVM's storage proof.   With anchoring, the block mapping function $M$  can be simplified:

\begin{eqnarray}
B & \equiv & (H, T, U), \\
\nonumber & \equiv &  M(\boldsymbol{\delta}, \boldsymbol{\theta}, \bar{B}, )  \\
\nonumber & \equiv & M(\boldsymbol{\delta},  \boldsymbol{\theta}, C, L)
\end{eqnarray}

\item Comparing $i$, $d$, $h[2..256])$ with values persisted by previous blocks. The anchor transaction will throw if any comparison fails, which will make this block unprovable on L1.
\item Inserting \textbf{anchorHeight} $C_a$ and \textbf{anchorHash} $C_h$ into a mapping structure on L2 as a key-value pair. These L1 block hashes can be used by bridges to validate cross-layer messages.
\end{enumerate}

We can add additional duties to anchor transaction implementation to enrich Taiko's functionalities without requesting changes in Taiko's zkEVM subsystem.

\subsubsection{Construction of Anchor Transactions} All anchor transactions are signed by a goldfinger address with a revealed private-key. 

Anchor transactions are constructed by Taiko L2 nodes as follows:

\begin{eqnarray}
& & \boldsymbol{\theta}_x = 0 \quad \wedge \\
\nonumber& & \boldsymbol{\theta}_n = \boldsymbol{\delta}[K_{\mathrm{GoldfingerAddress}}]_n + 1 \quad \wedge \\
\nonumber& & \boldsymbol{\theta}_p = 0 \quad \wedge \\
\nonumber& & \boldsymbol{\theta}_g = K_{\mathrm{AnchorTxGasLimit}} \quad \wedge \\
\nonumber& & \boldsymbol{\theta}_t = K_{\mathrm{GoldfingerAddress}} \quad \wedge  \\
\nonumber& & \boldsymbol{\theta}_v = 0 \quad \wedge  \\
\nonumber& & \boldsymbol{\theta}_d = K_{\mathrm{AnchorTxSelector}}::C_a::C_h \quad \wedge  \\
\nonumber& & (\boldsymbol{\theta}_r,\boldsymbol{\delta}_s) = \texttt{K1ECDSA}(\boldsymbol{\delta}, K_{\mathrm{GoldfingerPrivateKey}})
\end{eqnarray}

Where \texttt{K1ECDSA} is the ECDSA\cite{ecdsa} signing function with the internal variable $k$ set to $1$, which guarantees the transaction's signature to only depend on the transaction itself and therefore is deterministic\cite{ecdsak}.

According to ECDSA's spec, when $k$ is $1$, $\boldsymbol{\theta}_r$ must equal $\mathrm{G_x}$, the value of the x-coordinate of the base point on the SECP-256k1 curve. The TaikoL1 contract verifies this assertion.





\subsection{Proving Blocks} \label{sec:proving}

Proving a block creates a Fork Choice which is an attestation that the block in question transits a prover-selected parent block's corresponding world state to a new world state. A Fork Choice is a tuple of 3 elements:

\begin{equation}
E \equiv (H_p, H_h, [(a_1, P^{zk}_1, P^{tx}_1),...])
\end{equation}

where $H_p$ is the block's parent hash, $H_h \equiv \texttt{KEC}(\texttt{RLP}(H))$ is the hash of the proposed block after being mapped in L2, and $(a_n, P^{zk}_n, P^{tx}_n)$ are the n-th prover's address and the proofs. $P^{zk}$ is a zero-knowledge proof (ZKP) from zkEVM that proves the state transition from the parent hash is correct , and $P^{tx}$ is a merkle proof that proves the anchor transaction is valid and is the first transaction of the block in L2.

Taiko allows up to $K_{\mathrm{MaxProofsPerForkChoice}}$ provers per fork choice, but sets no limit on the number of fork choices.

\subsubsection{Proving Invalid Blocks} \label{sec:provinginvaid}

If a block fails to pass the Intrinsic Validity Function $V^l$, the block can be proven invalid using a valid throw-away L2 block $\hat{B}$ whose first transaction is a TaikoL2 $invalidateBlock$ transaction with the target block's txList as the sole input. $invalidateBlock$ will emit an $BlockInvalidated$ event with the target block's txList hash as a topic. On L1, we simply needs to verify that:

\begin{enumerate}
\item The throw-away block is $\hat{B}$ valid.
\item The first event emitted in the block is $BlockInvalidated$ event with the expected txList hash. 
\end{enumerate}

The Fork Choice for an invalid block is:

\begin{equation}
E \equiv (H_p, H_h \equiv K_{\mathrm{BlockDeadEndHash}}, [(a_1, P^{zk}_1, P^{tx}_1),...])
\end{equation}

Where $K_{\mathrm{BlockDeadEndHash}}$ is a special value marking this Fork Choice is for an invalid block; $P^{zk}$ and  $P^{tx}$ prove the throw-away block is invalid, not the target proposed block.

It's very important to notice that throw-away blocks are not mapped to L2 and are never part of the Taiko chain.

\subsection{Finalizing Blocks}\label{sec:finalizing}

Assuming the j-th block is the last finalized valid block. The i-th block (i > j) can be finalized if 1) the (i-1)-th block has been finalized, and 2) the i-th block has a Fork Choice $E$ whose parent block hash $E(H_p)$ equals the the j-th block's hash.

If $H_h$ equals $K_{\mathrm{BlockDeadEndHash}}$, the i-th block is marked as finalized, j is not updated; otherwise,  $j$ changes to $i$ so now the i-th block becomes the last finalized valid block. Obviously on L1, Taiko's canonical chain is a subset of all proposed blocks linked through Fork Choices; on L2, Taiko's canonical chain is a subset of all proposed blocks filtered by the Intrinsic Validity Function.

\subsection{Deterministic Blocks}
To enable parallel ZKP computation, all blocks, once proposed on L1, must have deterministic state transitions on L2. Our design ensures all potential public and private inputs are verified on L1 directly or indirectly to achieve deterministic block transitions.

\subsection{Assumptions on zkEVM}

What a ZKP can and cannot prove is critical to a zkRollup's protocol design. Taiko's current protocol design is fundamentally different from the one we had in Q2 2022, mainly because we adopted a new set of ZKP assumptions that will be outlined in this section.


\subsubsection{ZKP Computation}

$$ p^i_a = Z(H^i, a, r^i, X^i, T^i) $$


\subsubsection{ZKP Verification}

aaa

\end{multicols}

\bibliographystyle{IEEEtran}
\bibliography{main}

\appendix

\section{Terminology} \label{ch:Terminology}

\begin{description}
\item[Anchor Transaction] The first transaction in every Taiko L2 block to perform data validation and cross-layer communication.

\item[Goldfinger Address] An address with revealed private-key to transact all anchor transactions.

\item[Fork Choice] A data structure to capture a block's proving result based on a prover-chosen parent block.

\end{description}


\section{Ethereum Upgrades on Taiko}\label{sec:hardforks}

\begin{tabu}{l r }
\toprule
Name & Status \\
\midrule
EIP-606 -- Hardfork Meta: Homestead & \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad Enabled \\
EIP-779 -- Hardfork Meta: DAO Fork & Disabled \\
EIP-150 - Gas cost changes for IO-heavy operations & Enabled \\
EIP-155 -- Simple replay attack protection &  Enabled \\
EIP-158 -- State clearing) & Enabled \\
EIP-609 -- Hardfork Meta: Byzantium & Enabled \\
EIP-1013 -- Hardfork Meta: Constantinople & Enabled \\
EIP-1716 -- Hardfork Meta: Petersburg & Enabled \\
EIP-1679 -- Hardfork Meta: Istanbul & Enabled \\
EIP-2387 -- Hardfork Meta: Muir Glacier & Disabled \\
Berlin Network Upgrade & Enabled \\
London Network Upgrade & Disabled \\
Arrow Glacier Network Upgrade & Disabled \\
EIP-3675 -- Upgrade consensus to Proof-of-Stake & Enabled \\
Shanghai Network Upgrade & Disabled (future) \\
Cancun Network Upgrade & Disabled (future)  \\
\bottomrule
\end{tabu}



\section{Protocol Constants}\label{sec:constants1}

\begin{tabu}{l r l}
\toprule
Name & Value & Description \\
\midrule
$K_{\mathrm{ChainID}}$ & 1337 & Taiko's chain ID. \\
$K_{\mathrm{MaxPendingBlocks}}$ & 2048 & The maximum number of pending blocks. \\
$K_{\mathrm{MaxFinalizationsPerTx}}$ & 5 & The number of proven blocks that can be finalized when a new block is\\
& & proposed or a pending block is proven. \\
$K_{\mathrm{CommitDelayConfirmations}}$ & 4 & The number of confirmations to wait for before a block can be proposed\\
& &  after its commit-hash has been written on Ethereum.\\
$K_{\mathrm{MaxProofsPerForkChoice}}$ & 5 & The maximum number of proofs per fork choice. \\
$K_{\mathrm{BlockMaxGasLimit}}$ & 5000000 & A Taiko block's max gas limit besides $K_{\mathrm{AnchorTxGasLimit}}$.  \\
$K_{\mathrm{BlockMaxTxs}}$ & 20 & The maximum number of transactions in a Taiko block besides the anchor\\
& & transaction. \\
$K_{\mathrm{BlockDeadEndHash}}$ & 0x1 & A special value to mark blocks proven invalid. \\
$K_{\mathrm{TxListMaxBytes}}$ & 10240 & A txList's maximum number of bytes. \\
$K_{\mathrm{TxMinGasLimit}}$ & 21000 & A transaction's minimum gas limit. \\
$K_{\mathrm{AnchorTxGasLimit}}$ & 100000 & Anchor transaction's fixed gas limit. \\
\bottomrule
\end{tabu}

\begin{tabu}{l l}
\toprule
Name &  \quad \quadValue \\
\midrule
$K_{\mathrm{AnchorTxSelector}}$ &  \quad \quad 0xa0ca \\
$K_{\mathrm{GoldfingerAddress}}$ &  \quad \quad 0x0000777735367b36bC9B61C50022d9D0700dB4Ec  \\
$K_{\mathrm{GoldfingerPrivateKey}}$ & \quad \quad 0x92954368afd3caa1f3ce3ead0069c1af414054aefe1ef9aeacc1bf426222ce38 \\
$K_{\mathrm{InvalidateBlockLogTopic}}$ & \quad \quad 0x64b299ff9f8ba674288abb53380419048a4271dda03b837ecba6b40e6ddea4a2 \\
$K_{\mathrm{EmptyOmersHash}}$ & \quad \quad 0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347   \quad \quad \quad \quad \\
\bottomrule
\end{tabu}

\end{document}