\documentclass[9pt,oneside]{amsart}
%\usepackage{tweaklist}
\usepackage{cancel}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[a4paper,width=170mm,top=18mm,bottom=22mm,includeheadfoot]{geometry}
\usepackage{booktabs}
\usepackage{array}
\usepackage{verbatim}
\usepackage{caption}
\usepackage{natbib}
\usepackage{float}
\usepackage{pdflscape}
\usepackage{mathtools}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{afterpage}
\usepackage{tikz}
\usepackage[bookmarks=true, unicode=true, pdftitle={Taiko: A TIER-1 ETHEREUM ZK-ROLLUP}, pdfauthor={Taiko Labs},pdfkeywords={Ethereum, White Paper, blockchain,EVM, zkEVM, ZK-Rollup, Layer 2},pdfborder={0 0 0.5 [1 3]}]{hyperref}
%,pagebackref=true

\usepackage{tabu} %requires array.

%This should be the last package before \input{Version.tex}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
% "hyperref loads the url package internally. Use \PassOptionsToPackage{hyphens}{url}\usepackage{hyperref} to pass the option to the url package when it is loaded by hyperref. This avoids any package option clashes." Source: <https://tex.stackexchange.com/questions/3033/forcing-linebreaks-in-url/3034#comment44478_3034>.
% Note also this: "If the \PassOptionsToPackage{hyphens}{url} approach does not work, maybe it's "because you're trying to load the url package with a specific option, but it's being loaded by one of your packages before that with a different set of options. Try loading the url package earlier than the package that requires it. If it's loaded by the document class, try using \RequirePackage[hyphens]{url} before the document class." Source: <https://tex.stackexchange.com/questions/3033/forcing-linebreaks-in-url/3034#comment555944_3034>.
% For more information on using the hyperref package, refer to e.g. https://en.wikibooks.org/w/index.php?title=LaTeX/Hyperlinks&stable=0#Hyperlink_and_Hypertarget.

\makeatletter
 \newcommand{\linkdest}[1]{\Hy@raisedlink{\hypertarget{#1}{}}}
\makeatother
\usepackage{seqsplit}

% For formatting
%\usepackage{underscore}
%\usepackage{lipsum} % to generate filler text for testing of document rendering
\usepackage[english]{babel}
\usepackage[autostyle]{csquotes}
\MakeOuterQuote{"}

\usepackage[final]{microtype} % https://tex.stackexchange.com/questions/75140/is-it-possible-to-make-latex-mark-overfull-boxes-in-the-output#comment382776_75142


% Default rendering options
\definecolor{pagecolor}{rgb}{0.96,0.96,1}
\def\VersionNumber{0.1.0}
\IfFileExists{Options.tex}{\input{Options.tex}}

\newcommand{\hcancel}[1]{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {#1};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}%


\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\newcommand*\eg{e.g.\@\xspace}
\newcommand*\Eg{e.g.\@\xspace}
\newcommand*\ie{i.e.\@\xspace}
\newcommand{\thedate}{\today}
%\renewcommand{\itemhook}{\setlength{\topsep}{0pt}  \setlength{\itemsep}{0pt}\setlength{\leftmargin}{15pt}}

\title[TAIKO: A Tier-1 Ethereum ZK-Rollup\\ \smaller \textbf{{DRAFT \VersionNumber}}]{TAIKO: A Tier-1 Ethereum ZK-Rollup \\ \smaller \textbf{{DRAFT \VersionNumber, \thedate}}}

\author{
  Daniel WANG\\
  \texttt{dan@taiko.xyz}
  \and
  Brecht Devos\\
  \texttt{brecht@taiko.xyz}
}
\begin{document}

\pagecolor{pagecolor}

\begin{abstract}
TBD
\end{abstract}

\maketitle

\setlength{\columnsep}{20pt}
\begin{multicols}{2}


\section{Introduction}

TBD

\subsection{Design Principles}

TBD

\section{Rollup Contracts}
The Taiko ZK-Rollup protocol has two major smart contracts deployed on L1 and L2, respectively.

\subsection{TaikoL1} Deployed at address $\mathbf{r_{\mathrm{1}}}$ on Ethereum, this contract is used to propose, prove, and finalize blocks. TaikoL1  maintains the following rollup state variables:

\begin{description}
\item[nextBlockId] The ID for the next proposed block, formally $R_\mathrm{i}$.
\item[lastFinalizedBlockId] The ID of the last finalized block, formally $R_\mathrm{f}$.
% \item [numUnprovenBlocks] The number of proposed blocks that have not been proven,  formally $R_\mathrm{n}$.
\item [blockCommits] The mapping from proposed block \textit{commit hashes} to their enclosed L1 blocks' block numbers, formally $R_\mathrm{c}$. If a block's hash is $h$, the commit hash number is $R_\mathrm{c}[h]$.
\item[forkChoices] The mapping from proposed block IDs to their \textit{Fork Choices} , formally $R_\mathrm{f}$. The fork choices for the $i$-th block is $R_\mathrm{f}[i]$. Fork choices is discussed in detail in section \ref{sec:forkchoices}.
\item[pendingBlocks] The list of pending (unproven) proposed blocks, formally $R_\mathrm{b}$.
\end{description}



\subsection{TaikoL2} Deployed at address $\mathbf{r_{\mathrm{2}}}$ on Taiko, this contracts offers two major functionalities:
\begin{itemize}
\item Proving a proposed block is invalid on L2 through a valid but throwaway block.
\item Achieving \textit{anchoring}, an important concept in Taiko's design to ensure blocks are valid and cross-layer data exchange are done right. Anchoring is discussed in section \ref{sec:anchoring}
\end{itemize}

\section{Blocks and Transactions}

\subsection{Proposing Blocks}
All Taiko blocks are proposed permissionlessly on Ethereum then converted to actual L2 blocks if they are proven to be valid, or ignored if they are proven to be invalid.

\subsubsection{Proposed Block} The proposed block in Taiko is the collection of information (known as the block's \textit{context}), $C$, and a list of transactions, $L$,  (known as the block \textit{txList}). Formally, we can refer to a proposed block $\bar{B}$:

\begin{equation}
\bar{B} \equiv (\bar{B}_{\mathrm{C}}, \bar{B}_{\mathbf{L}})
\end{equation}

\subsubsection{Block Context} The block context, $C$, is a tuple of 1000000 items comprising:


  
    
\begin{description}
\item[id] A scalar value equal to the number of already proposed blocks.The genesis block has a number of zero; formally $C_{\mathrm{i}}$.
\item[beneficiary] The 160-bit address to which all fees collected from the corresponding L2 block be transferred; formally $C_{\mathrm{c}}$.
\item[gasLimit] The total gas limit used by the corresponding L2 block; formally $C_{\mathrm{l}}$.
\item[proposedAt] The timestamp when this block is proposed on L1; formally $C_{\mathrm{s}}$.
\item[mixHash] The mixHash value to be used by the corresponding L2 block; formally $C_{\mathrm{m}}$.
\item[extraData] The extraData value to be used by the corresponding L2 block;. This must be 32 bytes or fewer; formally $C_{\mathrm{x}}$.
\item[txListHash] The Keccak 256-bit hash (or the KZG polynomial commitment when EIP-4844 is enabled) of this block's txList; formally $C_{\mathrm{t}}$. 
\item[anchorHeight] The enclosing L1 block's parent block number; formally $C_{\mathrm{a}}$.
\item[anchorHash] The enclosing L1 block's parent block hash; formally $C_{\mathrm{h}}$.
\end{description}

\subsubsection{txList}\label{sec:txlist}
The txList is a RLP-serialised list of proposed L2 transactions. When EIP-4844 is enabled, txLists will be published on L1 as blobs and become inaccessible from the TaikoL1 contract, thus we demand that TaikoL1 shall only access a txList to calculate its hash, as opposed to read bytes from it. Such a constrain allows our design outlined in this paper (and current implementations) to remain valid when blobs are used to further reduce data cost.




\subsubsection{Proposed Block Intrinsic Validity}
The proposed block must pass an \textit{intrinsic validity} test before it is accepted by the TaikoL1 contract. 

We are able to define the intrinsic validity function $V(\bar{B})$:

\begin{eqnarray}
V(\bar{B}[i]) & \equiv &   V(C,L)  \\
\nonumber & \equiv &   R_\mathbf{i} \le R_\mathbf{f} + K_\mathrm{MaxPendingBlocks}   \quad \wedge \\
\nonumber& & \lVert L \rVert > 0 \quad \wedge \\
\nonumber & & \lVert L \rVert \le K_{\mathrm{TxListMaxBytes}} \quad \wedge \\
\nonumber& & C_{\mathbf{c}} \ne 0   \quad \wedge \\
\nonumber& & C_{\mathbf{i}} = R_\mathbf{i}   \quad \wedge \\
\nonumber& & C_{\mathbf{s}} = \texttt{TIMESTAMP}   \quad \wedge \\
\nonumber& & C_{\mathbf{m}} = \texttt{DIFFICULTY}   \quad \wedge \\
\nonumber& & C_{\mathbf{t}} \ne 0   \quad \wedge \\
\nonumber& & C_{\mathbf{t}} = \texttt{KEC}(L)   \quad \wedge \\
\nonumber& & C_{\mathbf{a}} = \texttt{NUMBER} - 1   \quad \wedge \\
\nonumber& & C_{\mathbf{h}} = \texttt{BLOCKHASH}(C_{\mathbf{a}})   \quad \wedge \\
\nonumber& & R_{\mathbf{c}}[\texttt{KEC}((C_{\mathbf{c}}, C_{\mathbf{t}}))] \ne 0  \quad \wedge \\
\nonumber& & R_{\mathbf{c}}[\texttt{KEC}((C_{\mathbf{c}}, C_{\mathbf{t}}))] \le  \\
\nonumber& &  \texttt{NUMBER}   -  K_{\mathrm{CommitDelayConfirmations}}
\end{eqnarray}

Where $\texttt{KEC}((C_{\mathbf{c}}, C_{\mathbf{t}}))$ is called the block's \textit{commit hash}.

After passing the test, the proposed block appends itself to the end of $R_\mathrm{b}$, the pending block list; $R_\mathrm{i}$ will increment by one; and its commit hash is deleted.


\subsubsection{Commit Hash} The commit hash is the Keccak 256-bit hash of a proposed block's \textbf{beneficiary} and \textbf{txListHash}. The Taiko ZK-Rollup protocol requires that a block can be proposed only $K_{\mathrm{CommitDelayConfirmations}}$ confirmations after its commit hash has been committed to  {TaikoL1}, which is a measure against MEV attack \cite{mevethfoundation} as block txLists are unencrypted.

Thanks to its commit hash, a block can be proposed by an arbitrary address, i.e., $\mathbf{msg.sender}$ dose not matter.

\subsection{Block Validation and Mapping } \label{sec:filtermap}
Taiko L2 node software filters pending proposed blocks using the \textit{txList Intrinsic Validity Function} $V^l$ on each block's txList $L$. If $V^l(L)$ returns \texttt{False}, the proposed block is dropped and ignored; otherwise, the proposed block will map to an actual Taiko L2 block using a \textit{Block Mapping Function} $M(\hat{B})$.

\subsubsection{Validation} The txList Intrinsic Validity Function requires:

\begin{itemize}
\item The txList is RLP decodable into a list of transactions, and;
\item The number of transactions is no larger than  protocol constant $ K_{\mathrm{BlockMaxTxs}}$, and;
\item The sum of all transaction's gasLimit is no larger than protocol constant $K_{\mathrm{BlockMaxGasLimit}}$, and;
\item Each and every transaction's signature is valid, i.e., it does not recover to the zero address.
\end{itemize}

Formally, $V^l(L)$ is defined as:


\begin{eqnarray}
V^l(L) & \equiv & \texttt{NOERR}(T \equiv \texttt{RLP}'(L))  \quad \wedge  \\
\nonumber& & \lVert T \rVert \le K_{\mathrm{BlockMaxTxs}} \quad \wedge \\
\nonumber & & (\sum_{j = 0}^{\lVert T \rVert - 1}T[j]_g) \le K_{\mathrm{BlockMaxGasLimit}} \quad \wedge \\
\nonumber & & \prod_{j = 0}^{\lVert T \rVert - 1} (T[j]_g \ge K_{\mathrm{TxMinGasLimit}})\quad \wedge \\
\nonumber & & \prod_{j = 0}^{\lVert T \rVert - 1} (\texttt{NOERR}(\texttt{ECRECOVER}(T[j]) \ne 0) )
\end{eqnarray}

Where $\texttt{NOERR(S)}$ is a catch-error function that returns \texttt{False} if statement $S$ throws an error; $\texttt{RLP}'$ is the RLP decode function;  $T_g$ represents a transaction's \textbf{gasLimit}; 





It is important to realize that the txList Intrinsic Validity Function cannot be called on L1 as txLists are not accessible to Ethereum EVM on the byte level, as explained in \ref{sec:txlist}, unless the same txLists are submitted again to L1 in the form of transaction calldata, which will be more expensive than blobs and should be avoided after EIP-4844.

\subsubsection{Mapping}

Each proposed block that $V^l(\bar{B}_L)$ returns $\texttt{True}$ maps to an actual Taiko L2 block. Taiko blocks have the same structure as Ethereum blocks as defined in in the Ethereum Yellow Paper \cite{ethyellowpaper}:

\begin{eqnarray}
B_H & \equiv & (H_p, H_o, H_c, H_r, H_t, H_e, H_b, H_d, \\
\nonumber & & H_i, H_l,H_g, H_s, H_x, H_m, H_n) \\
B_U  & \equiv & [] \\
B & \equiv & (B_H, B_T, B_U)
\end{eqnarray}

Where $H_p$ is the block's \textbf{parentHash}, $H_o$ is the \textbf{EmptyOmersHash}, $H_c$ is the \textbf{beneficiary}, $H_r$ is the \textbf{stateRoot}, $H_t$ is the \textbf{transactionsRoot}, $H_e$ is the \textbf{receiptsRoot}, $H_b$ is the \textbf{logsBloom}, $H_d$ is the \textbf{difficulty}, $H_i$ is the block \textbf{number}, $H_l$ is the \textbf{gasLimit}, $H_g$ is the \textbf{gasUsed}, $H_s$ is the \textbf{timestamp}, $H_x$ is the \textbf{extraData}, $H_m$ is the \textbf{mixHash}, $H_n$ is the \textbf{nonce}; $B_T$ a series of the transactions; and $B_U$ is a list of ommer block headers but is always empty for Taiko because there is no Proof-of-Work.

Transactions in Taiko also conform to the same Ethereum standard defined by the Ethereum Yellow Paper. But currently only type 0 (legacy) and type 1 transactions are supported as EIP-1559 is disabled on Taiko initially (but may be enabled in a future version).

A proposed block can only be mapped to a Taiko block in a \textit{mapping context} which is the world state $\boldsymbol{\sigma}$:

$$\boldsymbol{\sigma} \equiv (\boldsymbol{\delta}, h[1..256], d, i, \boldsymbol{\theta})$$

Where $\boldsymbol{\delta}$ is the trie, $h[1...256]$ are the most recent 256 ancestor block hashes; and $d$ is Taiko's chain ID, $\boldsymbol{\theta}$ is the anchor transaction, and $i$ is the block number.

Now we can define the block mapping function $M$ as:

\begin{eqnarray}
B & \equiv & (H, T, U), \\
\nonumber & \equiv &  M(\boldsymbol{\delta}, h[1..256], {d}, i, \boldsymbol{\theta}, \bar{B}, )  \\
\nonumber & \equiv & M(\boldsymbol{\delta}, h[1..256], {d}, i, \boldsymbol{\theta}, C, L)
\end{eqnarray}


such that:

\begin{eqnarray}
& & \texttt{CHAINID}  = \quad \wedge \\
\nonumber& & \texttt{NUMBER} = {i} \quad \wedge \\
\nonumber& & U = [] \quad \wedge \\
\nonumber& & T =  \boldsymbol{\theta}::F(\texttt{RLP}'(L), V^t) \quad \wedge  \\
\nonumber& & H_p =  h(1) \quad \wedge \\
\nonumber& & H_o =   K_{\mathrm{EmptyOmersHash}} \quad \wedge \\
\nonumber& & H_c =   C_c \quad \wedge \\
\nonumber& & H_d =   0 \quad \wedge \\
\nonumber& & H_i =   i \quad \wedge \\
\nonumber& & H_l =   C_l + K_{\mathrm{AnchorTxGasLimit}} \quad \wedge \\
\nonumber& & H_s =   C_s \quad \wedge \\
\nonumber& & H_x =   C_x \quad \wedge \\
\nonumber& & H_m =   C_m \quad \wedge \\
\nonumber& & (H_r, H_t, H_e, H_l, H_g) =   \Pi(\boldsymbol{\sigma}, (T_0, T_1, ...))
\end{eqnarray}

Where $\Pi$ is the block transition function; $::$ is the list concatenation operator; $V^t$ is the \textit{transaction intrinsic validity test function} defined in the Transaction Execution section of the Ethereum Yellow Paper. Transactions in the txList that fail the test will be ignored thus won't make into the L2 block.


\subsection{Anchoring} \label{sec:anchoring}

The anchor transaction is always the first one in a Taiko L2 block to perform certain duties:

\begin{itemize}
\item Persisting the values of $i$, $d$, $h[1]$ -- the parent block hash -- to the trie (for the next block to use), which enables $i$, $d$, $h[1]$ to be also covered by the zkEVM's storage proof.   With anchoring, the block mapping function $M$  can be simplified:

\begin{eqnarray}
B & \equiv & (H, T, U), \\
\nonumber & \equiv &  M(\boldsymbol{\delta}, \boldsymbol{\theta}, \bar{B}, )  \\
\nonumber & \equiv & M(\boldsymbol{\delta},  \boldsymbol{\theta}, C, L)
\end{eqnarray}

\item Comparing $i$, $d$, $h[2..256])$ with values persisted by previous blocks. The anchor transaction will throw if any comparison fails, which will make this block unprovable on L1.
\item Inserting \textbf{anchorHeight} $C_a$ and \textbf{anchorHash} $C_h$ into a mapping structure on L2 as a key-value pair. These L1 block hashes can be used by bridges to validate cross-layer messages.
\end{itemize}

We can add additional duties to anchor transaction implementation to enrich Taiko's functionalities without requesting changes in Taiko's zkEVM subsystem.

\subsubsection{Construction of Anchor Transactions} All anchor transactions are signed by a goldfinger address with a revealed private-key. 

Anchor transactions are constructed by Taiko L2 nodes as follows:

\begin{eqnarray}
& & \boldsymbol{\theta}_x = 0 \quad \wedge \\
\nonumber& & \boldsymbol{\theta}_n = \boldsymbol{\delta}[K_{\mathrm{GoldfingerAddress}}]_n + 1 \quad \wedge \\
\nonumber& & \boldsymbol{\theta}_p = 0 \quad \wedge \\
\nonumber& & \boldsymbol{\theta}_g = K_{\mathrm{AnchorTxGasLimit}} \quad \wedge \\
\nonumber& & \boldsymbol{\theta}_t = K_{\mathrm{GoldfingerAddress}} \quad \wedge  \\
\nonumber& & \boldsymbol{\theta}_v = 0 \quad \wedge  \\
\nonumber& & \boldsymbol{\theta}_d = K_{\mathrm{AnchorTxSelector}}::C_a::C_h \quad \wedge  \\
\nonumber& & (\boldsymbol{\theta}_r,\boldsymbol{\delta}_s) = \texttt{K1ECDSA}(\boldsymbol{\delta}, K_{\mathrm{GoldfingerPrivateKey}})
\end{eqnarray}

Where \texttt{K1ECDSA} is the ECDSA signing function with the internal variable $k$ set to $1$, which guarantees the transaction's signature to only depend on the transaction itself and therefore is deterministic.

According to ECDSA's spec, when $k$ is $1$, $\boldsymbol{\theta}_r$ must equal $\mathrm{G_x}$, the value of the x-coordinate of the base point on the SECP-256k1 curve. The TaikoL1 contract verifies this assertion.





\subsection{Proving Blocks} \label{sec:proving}





\subsubsection{Fork Choices} \label{sec:forkchoices}






\subsection{Assumptions on zkEVM}
hi hi hi



\bibliographystyle{abbrv}
\bibliography{main}

\end{multicols}


\appendix

\section{Terminology} \label{ch:Terminology}

\begin{description}
\item[External Actor] A person or other entity able to interface to an Ethereum node, but external to the world of Ethereum. It can interact with Ethereum through depositing signed Transactions and inspecting the blockchain and associated state. Has one (or more) intrinsic Accounts.

\item[Address] A 160-bit code used for identifying Accounts.

\item[Account] Accounts have an intrinsic balance and transaction count maintained as part of the Ethereum state. They also have some (possibly empty) EVM Code and a (possibly empty) Storage State associated with them. Though homogenous, it makes sense to distinguish between two practical types of account: those with empty associated EVM Code (thus the account balance is controlled, if at all, by some external entity) and those with non-empty associated EVM Code (thus the account represents an Autonomous Object). Each Account has a single Address that identifies it.

\end{description}

\section{Protocol Constants}\label{sec:constants1}

\subsection{}
\begin{tabu}{l r l}
\toprule
Name & Value & Description \\
\midrule
$K_{\mathrm{ChainID}}$ & 1337 & Taiko's chain ID. \\
$K_{\mathrm{MaxPendingBlocks}}$ & 2048 & The maximum number of pending blocks. \\
$K_{\mathrm{MaxFinalizationsPerTx}}$ & 5 & The number of proven blocks that can be finalized when a new block is\\
& & proposed or a pending block is proven. \\
$K_{\mathrm{CommitDelayConfirmations}}$ & 4 & The number of confirmations to wait for before a block can be proposed\\
& &  after its commit-hash has been written on Ethereum.\\
$K_{\mathrm{MaxProofsPerForkChoice}}$ & 5 & The maximum number of proofs per fork choice. \\
$K_{\mathrm{BlockMaxGasLimit}}$ & 5000000 & A Taiko block's max gas limit besides $K_{\mathrm{AnchorTxGasLimit}}$.  \\
$K_{\mathrm{BlockMaxTxs}}$ & 20 & The maximum number of transactions in a Taiko block besides the anchor\\
& & transaction. \\
$K_{\mathrm{BlockDeadEndHash}}$ & 0x1 & A special value to mark blocks proven to be invalid. \\
$K_{\mathrm{TxListMaxBytes}}$ & 10240 & A txList's maximum number of bytes. \\
$K_{\mathrm{TxMinGasLimit}}$ & 21000 & A transaction's minimum gas limit. \\
$K_{\mathrm{AnchorTxGasLimit}}$ & 100000 & Anchor transaction's fixed gas limit. \\
\bottomrule
\end{tabu}

\subsection{}

\begin{tabu}{l l}
\toprule
Name &  \quad \quadValue \\
\midrule
$K_{\mathrm{AnchorTxSelector}}$ &  \quad \quad 0xa0ca \\
$K_{\mathrm{GoldfingerAddress}}$ &  \quad \quad 0x0000777735367b36bC9B61C50022d9D0700dB4Ec  \\
$K_{\mathrm{GoldfingerPrivateKey}}$ & \quad \quad 0x92954368afd3caa1f3ce3ead0069c1af414054aefe1ef9aeacc1bf426222ce38 \\
$K_{\mathrm{InvalidateBlockLogTopic}}$ & \quad \quad 0x64b299ff9f8ba674288abb53380419048a4271dda03b837ecba6b40e6ddea4a2 \\
$K_{\mathrm{EmptyOmersHash}}$ & \quad \quad 0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347   \quad \quad \quad \quad \\
\bottomrule
\end{tabu}

\end{document}