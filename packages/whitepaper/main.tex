\documentclass[9pt,oneside]{amsart}
%\usepackage{tweaklist}
\usepackage{cancel}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[a4paper,width=170mm,top=18mm,bottom=22mm,includeheadfoot]{geometry}
\usepackage{booktabs}
\usepackage{array}
\usepackage{verbatim}
\usepackage{caption}
\usepackage{natbib}
\usepackage{float}
\usepackage{pdflscape}
\usepackage{mathtools}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{afterpage}
\usepackage{tikz}
\usepackage[bookmarks=true, unicode=true, pdftitle={Ethereum Yellow Paper: a formal specification of Ethereum, a programmable blockchain}, pdfauthor={Dr. Gavin Wood},pdfkeywords={Ethereum, Yellow Paper, blockchain, virtual machine, cryptography, decentralised, singleton, transaction, generalised},pdfborder={0 0 0.5 [1 3]}]{hyperref}
%,pagebackref=true

\usepackage{tabu} %requires array.

%This should be the last package before \input{Version.tex}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
% "hyperref loads the url package internally. Use \PassOptionsToPackage{hyphens}{url}\usepackage{hyperref} to pass the option to the url package when it is loaded by hyperref. This avoids any package option clashes." Source: <https://tex.stackexchange.com/questions/3033/forcing-linebreaks-in-url/3034#comment44478_3034>.
% Note also this: "If the \PassOptionsToPackage{hyphens}{url} approach does not work, maybe it's "because you're trying to load the url package with a specific option, but it's being loaded by one of your packages before that with a different set of options. Try loading the url package earlier than the package that requires it. If it's loaded by the document class, try using \RequirePackage[hyphens]{url} before the document class." Source: <https://tex.stackexchange.com/questions/3033/forcing-linebreaks-in-url/3034#comment555944_3034>.
% For more information on using the hyperref package, refer to e.g. https://en.wikibooks.org/w/index.php?title=LaTeX/Hyperlinks&stable=0#Hyperlink_and_Hypertarget.

\makeatletter
 \newcommand{\linkdest}[1]{\Hy@raisedlink{\hypertarget{#1}{}}}
\makeatother
\usepackage{seqsplit}

% For formatting
%\usepackage{underscore}
%\usepackage{lipsum} % to generate filler text for testing of document rendering
\usepackage[english]{babel}
\usepackage[autostyle]{csquotes}
\MakeOuterQuote{"}

\usepackage[final]{microtype} % https://tex.stackexchange.com/questions/75140/is-it-possible-to-make-latex-mark-overfull-boxes-in-the-output#comment382776_75142


% Default rendering options
\definecolor{pagecolor}{rgb}{1,1,1}
\def\VersionNumber{0.1.0}
\IfFileExists{Options.tex}{\input{Options.tex}}

\newcommand{\hcancel}[1]{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {#1};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}%


\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\newcommand*\eg{e.g.\@\xspace}
\newcommand*\Eg{e.g.\@\xspace}
\newcommand*\ie{i.e.\@\xspace}
\newcommand{\thedate}{\today}
%\renewcommand{\itemhook}{\setlength{\topsep}{0pt}  \setlength{\itemsep}{0pt}\setlength{\leftmargin}{15pt}}

\title[TAIKO: A Tier-1 Ethereum ZK-Rollup\\ \smaller \textbf{{DRAFT \VersionNumber}}]{TAIKO: A Tier-1 Ethereum ZK-Rollup \\ \smaller \textbf{{DRAFT \VersionNumber, \thedate}}}

\author{
  Daniel WANG\\
  \texttt{dan@taiko.xyz}
  \and
  Brecht Devos\\
  \texttt{brecht@taiko.xyz}
}
\begin{document}

\pagecolor{pagecolor}

\begin{abstract}
TBD
\end{abstract}

\maketitle

\setlength{\columnsep}{20pt}
\begin{multicols}{2}


\section{Introduction}

TBD

\subsection{Design Principles}

TBD

\section{Rollup Contracts}
The Taiko ZK-Rollup protocol has two major smart contracts deployed on L1 and L2, respectively.

\subsection{TaikoL1} Deployed at address $\mathbf{r_{\mathrm{1}}}$ on Ethereum, this contract is used to propose, prove, and finalize blocks. TaikoL1  maintains the following rollup state variables:

\begin{description}
\item[nextBlockId] The ID for the next proposed block, formally $R_\mathrm{i}$.
\item[lastFinalizedBlockId] The ID of the last finalized block, formally $R_\mathrm{f}$.
% \item [numUnprovenBlocks] The number of proposed blocks that have not been proven,  formally $R_\mathrm{n}$.
\item [blockCommits] The mapping from proposed block \textit{commit hashes} to their enclosed L1 blocks' block numbers, formally $R_\mathrm{c}$. If a block's hash is $h$, the commit hash number is $R_\mathrm{c}[h]$.
\item[forkChoices] The mapping from proposed block IDs to their \textit{Fork Choices} , formally $R_\mathrm{f}$. The fork choices for the $i$-th block is $R_\mathrm{f}[i]$. Fork choices is discussed in detail in section \ref{sec:forkchoices}.
\item[pendingBlocks] The list of pending (unproven) proposed blocks, formally $R_\mathrm{b}$.
\end{description}




\subsection{TaikoL2} Deployed at address $\mathbf{r_{\mathrm{2}}}$ on Taiko, this contracts offers two major functionalities:
\begin{itemize}
\item Proving a proposed block is invalid on L2 through a valid but throwaway block.
\item Achieving \textit{anchoring}, an important concept in Taiko's design to ensure blocks are valid and cross-layer data exchanges are done right. Anchoring is discussed in section \ref{sec:anchoring}
\end{itemize}

\section{Blocks and Transactions}

\subsection{Proposing Blocks}
All Taiko blocks are proposed permissionlessly on Ethereum then converted to actual L2 blocks if they are proven to be valid, or ignored if they are proven to be invalid.

\subsubsection{Proposed Block} The proposed block in Taiko is the collection of information (known as the block's \textit{context}), $C$, and a list of transactions, $L$,  (known as the block \textit{txList}). Formally, we can refer to a proposed block $\bar{B}$:

\begin{equation}
\bar{B} \equiv (\bar{B}_{\mathrm{C}}, \bar{B}_{\mathbf{L}})
\end{equation}

\subsubsection{Block Context} The block context, $C$, is a tuple of 1000000 items comprising:


  
    
\begin{description}
\item[id] A scalar value equal to the number of already proposed blocks.The genesis block has a number of zero; formally $C_{\mathrm{i}}$.
\item[beneficiary] The 160-bit address to which all fees collected from the corresponding L2 block be transferred; formally $C_{\mathrm{c}}$.
\item[gasLimit] The total gas limit used by the corresponding L2 block; formally $C_{\mathrm{l}}$.
\item[proposedAt] The timestamp when this block is proposed on L1; formally $C_{\mathrm{s}}$.
\item[mixHash] The mixHash value to be used by the corresponding L2 block; formally $C_{\mathrm{m}}$.
\item[extraData] The extraData value to be used by the corresponding L2 block;. This must be 32 bytes or fewer; formally $C_{\mathrm{x}}$.
\item[txListHash] The Keccak 256-bit hash (or the KZG polynomial commitment when EIP-4844 is enabled) of this block's txList; formally $C_{\mathrm{t}}$. 
\item[anchorHeight] The enclosing L1 block's parent block number; formally $C_{\mathrm{a}}$.
\item[anchorHash] The enclosing L1 block's parent block hash; formally $C_{\mathrm{h}}$.
\end{description}

\subsubsection{txList}\label{sec:txlist}
The txList is a RLP-serialised list of proposed L2 transactions. When EIP-4844 is enabled, txLists will be published on L1 as blobs and become inaccessible from the TaikoL1 contract, thus we demand that TaikoL1 shall only access a txList to calculate its hash, as opposed to read bytes from it. Such a constrain allows our design outlined in this paper (and current implementations) to remain valid when blobs are used to further reduce data cost.




\subsubsection{Proposed Block Intrinsic Validity}
The proposed block must pass an \textit{intrinsic validity} test before it is accepted by the TaikoL1 contract. 

We are able to define the intrinsic validity function $V(\bar{B})$:

\begin{eqnarray}
V(\bar{B}[i]) & \equiv &   V(C,L)  \\
\nonumber & \equiv &   R_\mathbf{i} \le R_\mathbf{f} + K_\mathrm{pendingblocks}   \quad \wedge \\
\nonumber& & \lVert L \rVert > 0 \quad \wedge \\
\nonumber & & \lVert L \rVert \le K_{\mathrm{blocktxlistbytelimit}} \quad \wedge \\
\nonumber& & C_{\mathbf{c}} \ne 0   \quad \wedge \\
\nonumber& & C_{\mathbf{i}} = R_\mathbf{i}   \quad \wedge \\
\nonumber& & C_{\mathbf{s}} = \texttt{TIMESTAMP}   \quad \wedge \\
\nonumber& & C_{\mathbf{m}} = \texttt{DIFFICULTY}   \quad \wedge \\
\nonumber& & C_{\mathbf{t}} \ne 0   \quad \wedge \\
\nonumber& & C_{\mathbf{t}} = \texttt{KEC}(L)   \quad \wedge \\
\nonumber& & C_{\mathbf{a}} = \texttt{NUMBER} - 1   \quad \wedge \\
\nonumber& & C_{\mathbf{h}} = \texttt{BLOCKHASH}(C_{\mathbf{a}})   \quad \wedge \\
\nonumber& & R_{\mathbf{c}}[\texttt{KEC}((C_{\mathbf{c}}, C_{\mathbf{t}}))] \ne 0  \quad \wedge \\
\nonumber& & R_{\mathbf{c}}[\texttt{KEC}((C_{\mathbf{c}}, C_{\mathbf{t}}))] \le  \\
\nonumber& &  \texttt{NUMBER}   -  K_{\mathrm{commitdelay}}
\end{eqnarray}

where $\texttt{KEC}((C_{\mathbf{c}}, C_{\mathbf{t}}))$ is called the block's \textit{commit hash}.

After passing the test, the proposed block appends itself to the end of $R_\mathrm{b}$, the pending block list; $R_\mathrm{i}$ will increment by one; and its commit hash is deleted.


\subsubsection{Commit Hash} The commit hash is the Keccak 256-bit hash of a proposed block's \textbf{beneficiary} and \textbf{txListHash}. The Taiko ZK-Rollup protocol requires that a block can be proposed only \small{$K_{\mathrm{commitdelay}}$} confirmations after its commit hash has been committed to  {TaikoL1}, which is a measure against MEV attack (\cite{mevethfoundation}) as block txLists are unencrypted.

Thanks to its commit hash, a block can be proposed by an arbitrary address, i.e., $\mathbf{msg.sender}$ dose not matter.

\subsection{Mapping Blocks} \label{sec:filtermap}
Taiko L2 node software filters then maps pending proposed blocks to actual L2 blocks. The filter function $F$ is defined as:

\begin{equation}
F({\bar{B}[i]})  \equiv \hat{F}({L})
\end{equation}

Where $\hat{F}$ is called the \textit{txList Intrinsic Validity Function}.

Function $\hat{F}(L)$ returns true if:
\begin{itemize}
\item The txList can be decoded into a none-mpty list of Taiko transactions $T$ without error:

\begin{equation}
T  \equiv \texttt{RLP}'(L)
\end{equation}

where  $\texttt{RLP}'$ is the RLP decode function, and;

\item The total number of transactions is no larger than a protocol constant:
\begin{equation}
\lVert T \rVert \le K_{\mathrm{blockmaxtxs}}
\end{equation}

 
\item The sum of all transaction's gas limit is no larger than a protocol constant:

\begin{equation}
\sum_{j = 0}^{\lVert T \rVert - 1}(T[j]_g) \le K_{\mathrm{blockmaxgas}}
\end{equation}

where $T_g$ represents a transaction's \textbf{gasLimit}.


\item MORE



\end{itemize}

It is critical to realize that the filter functions cannot be called on L1 as txLists are not accessible to Ethereum EVM on the byte-level, as explained in \ref{sec:txlist}, unless the same txLists are submitted again to L1 in the form of transaction calldata,which will be more expensive than blobs and should be avoided after EIP-4844.

Each proposed block $\bar{B}$ that $F(\bar{B})$ returns $\texttt{True}$ maps to an actual Taiko L2 block $B$. A Taiko block $B$ has the following data as defined in Ethereum Yellow Paper:

\begin{eqnarray}
B_H & \equiv & (H_p, H_o, H_c, H_r, H_t, H_e, H_b, H_d, \\
\nonumber & & H_i, H_l,H_g, H_s, H_x, H_m, H_n) \\
B_U  & \equiv & [] \\
B & \equiv & (B_H, B_T, B_U)
\end{eqnarray}

where $H_p$ is the block's \textbf{parentHash}, $H_o$ is the \textbf{ommersHash}, $H_c$ is the \textbf{beneficiary}, $H_r$ is the \textbf{stateRoot}, $H_t$ is the \textbf{transactionsRoot}, $H_e$ is the \textbf{receiptsRoot}, $H_b$ is the \textbf{logsBloom}, $H_d$ is the \textbf{difficulty}, $H_i$ is the block \textbf{number}, $H_l$ is the \textbf{gasLimit}, $H_g$ is the \textbf{gasUsed}, $H_s$ is the \textbf{timestamp}, $H_x$ is the \textbf{extraData}, $H_m$ is the \textbf{mixHash}, $H_n$ is the \textbf{nonce}; $B_T$ a series of the transactions; and $B_U$ is a list of ommer block headers but is always empty for Taiko because there is no Proof-of-Work.

Transactions in Taiko also conform to the same Ethereum standard defined by the Ethereum Yellow Paper. But currently only type 0 (legacy) and type 1 transactions are supported as EIP-1559 is disabled on Taiko initially (but will be enabled in a future version).

Now we can define the block mapping function $M$ as 
\begin{equation}
B \equiv M(H'_p, \bar{B}, )  \equiv M(H'_p, C, L)
\end{equation}

where $H'_p$ is this block's parent hash known to the Taiko node, such that:

\begin{eqnarray}
& & H_p \equiv H'_p \quad \wedge \\
\nonumber & & H_o \equiv  K_{\mathrm{ommershash}} \quad \wedge \\
\nonumber& & H_c \equiv  C_c \quad \wedge \\
\nonumber& & H_r \equiv  C_r \quad \wedge \\
\end{eqnarray}








\subsection{Proving Blocks} \label{sec:proving}





\subsubsection{Fork Choices} \label{sec:forkchoices}




\subsection{Anchoring} \label{sec:anchoring}

\subsection{Assumptions on zkEVM}
hi hi hi

\newpage

\bibliographystyle{plainnat}
\bibliography{whitepaper}

\end{multicols}


\appendix

\section{Terminology} \label{ch:Terminology}

\begin{description}
\item[External Actor] A person or other entity able to interface to an Ethereum node, but external to the world of Ethereum. It can interact with Ethereum through depositing signed Transactions and inspecting the blockchain and associated state. Has one (or more) intrinsic Accounts.

\item[Address] A 160-bit code used for identifying Accounts.

\item[Account] Accounts have an intrinsic balance and transaction count maintained as part of the Ethereum state. They also have some (possibly empty) EVM Code and a (possibly empty) Storage State associated with them. Though homogenous, it makes sense to distinguish between two practical types of account: those with empty associated EVM Code (thus the account balance is controlled, if at all, by some external entity) and those with non-empty associated EVM Code (thus the account represents an Autonomous Object). Each Account has a single Address that identifies it.

\end{description}

\section{Protocol Constant Values}\label{app:fees}

\nopagebreak
The fee schedule $G$ is a tuple of scalar values corresponding to the relative costs, in gas, of a number of abstract operations that a transaction may effect.

\nopagebreak
\begin{tabu}{l r l}
\toprule
Name & Value & Description \\
\midrule
$K_{\mathrm{chainid}}$ & 1337 & Nothing paid for operations of the set {\small $W_{\mathrm{zero}}$}. \\
$K_{\mathrm{pendingblocks}}$ & 2048 & Nothing paid for operations of the set {\small $W_{\mathrm{zero}}$}. \\
$K_{\mathrm{perblockfinalization}}$ & 5 & Amount of gas to pay for a {\small JUMPDEST} operation. \\
$K_{\mathrm{commitdelay}}$ & 4 & Amount of gas to pay for operations of the set {\small $W_{\mathrm{base}}$}. \\
$K_{\mathrm{perblockforks}}$ & 5 & Amount of gas to pay for operations of the set {\small $W_{\mathrm{verylow}}$}. \\
$K_{\mathrm{blockmaxgas}}$ & 1000000 & Amount of gas to pay for operations of the set {\small $W_{\mathrm{block}}$}. \\
$K_{\mathrm{blockmaxtxs}}$ & 8 & Amount of gas to pay for operations of the set {\small $W_{\mathrm{mid}}$}. \\
$K_{\mathrm{blocktxlistbytelimit}}$ & 1000000 & Amount of gas to pay for operations of the set {\small $W_{\mathrm{high}}$}. \\
$K_{\mathrm{anchorgas}}$ & 100 & Cost of a warm account or storage access. \\
$K_{\mathrm{goldfingeraddr}}$ & 100 & Cost of a warm account or storage access. \\
$K_{\mathrm{goldfingerprivatekey}}$ & 100 & Cost of a warm account or storage access. \\
$K_{\mathrm{deadendmark}}$ & 1 & Cost of a warm account or storage access. \\
$K_{\mathrm{invalidblocklogtopic}}$ & 0x64b299ff...6ddea4a2 & keccak256("BlockInvalidated(bytes32)"). \\
$K_{\mathrm{ommershash}}$ & 0x1dcc4de8...40d49347 & keccak256(RLP([]). \\
%extern u256 const c_{\mathrm{copyGas}};            ///< Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added.
\bottomrule
\end{tabu}




\end{document}