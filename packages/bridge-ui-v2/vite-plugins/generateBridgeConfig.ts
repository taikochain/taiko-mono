/* eslint-disable no-console */
import { promises as fs } from 'fs';
import path from 'path';
import * as prettier from 'prettier';
import { Project, SourceFile, VariableDeclarationKind } from 'ts-morph';
import type { Address } from 'viem';

import { Logger } from './utils/Logger';

const currentDir = path.resolve(new URL(import.meta.url).pathname);

// Todo: make paths and names configurable via .env?
const outputPath = path.join(path.join(path.dirname(currentDir)), '../src/generated/bridgeConfig.ts');

const configuredBridgesConfigFile = path.join(path.dirname(currentDir), '../config', 'configuredBridges.json');

type AddressConfig = {
    bridgeAddress: Address;
    erc20VaultAddress: Address;
    erc721VaultAddress: Address;
    erc1155VaultAddress: Address;
    crossChainSyncAddress: Address;
    signalServiceAddress: Address;
};

type BridgeConfig = {
    source: string;
    destination: string;
    addresses: AddressConfig;
};

type RoutingMap = Record<string, Record<string, AddressConfig>>;

const pluginName = 'generateBridgeConfig';
const logger = new Logger(pluginName);

export function generateBridgeConfig() {
    return {
        name: pluginName,
        async buildStart() {
            logger.info('Plugin initialized.');
            const project = new Project();

            // Path to where you want to save the generated TypeScript file
            const tsFilePath = path.resolve(outputPath);

            // Notification and warning message
            const timestamp = new Date().toLocaleString();
            const notification = `// Generated by ${pluginName} on ${timestamp}`;
            const warning = `// WARNING: Do not change this file manually as it will be overwritten`;

            // Create the TypeScript content
            let sourceFile = project.createSourceFile(tsFilePath, `${notification}\n${warning}\n`, { overwrite: true });

            // Create the TypeScript content

            // let sourceFile = project.createSourceFile(tsFilePath, undefined, { overwrite: true });

            sourceFile.addImportDeclaration({
                namedImports: ['Address'],
                moduleSpecifier: 'viem',
                isTypeOnly: true,
            });

            sourceFile = await storeTypesAndEnums(sourceFile);
            sourceFile = await buildBridgeConfig(sourceFile);

            // Save the file
            await sourceFile.saveSync();
            logger.info(`Generated config file`);

            const generatedCode = await fs.readFile(tsFilePath, 'utf-8');

            logger.info(`Formatting...`);
            // Format the code using Prettier
            const formattedCode = await prettier.format(generatedCode, { parser: 'typescript' });

            // Write the formatted code back to the file
            await fs.writeFile(tsFilePath, formattedCode);
            logger.info(`Formatted config file saved to ${tsFilePath}`);
        },
    };
}

async function storeTypesAndEnums(sourceFile: SourceFile) {
    logger.info(`Storing types and enums...`);


    // AddressConfig
    sourceFile.addTypeAlias({
        name: 'AddressConfig',
        isExported: true,
        type: `{ 
            bridgeAddress: Address;
            erc20VaultAddress: Address;
            erc721VaultAddress: Address;
            erc1155VaultAddress: Address;
            crossChainSyncAddress: Address;
            signalServiceAddress: Address;
        }`,
    });

    // RoutingMap
    sourceFile.addTypeAlias({
        name: 'RoutingMap',
        isExported: true,
        type: `Record<string, Record<string, AddressConfig>>`,
    });


    logger.info('Types and enums stored.');
    return sourceFile;
}

async function buildBridgeConfig(sourceFile: SourceFile) {
    logger.info('Building bridge config...');
    const routingContractsMap: RoutingMap = {};

    const bridgesJsonContent = await fs.readFile(configuredBridgesConfigFile, 'utf-8');

    const bridges = JSON.parse(bridgesJsonContent);
    if (!bridges.configuredBridges || !Array.isArray(bridges.configuredBridges)) {
        logger.error('configuredBridges is not an array. Please check the content of the configuredBridgesConfigFile.');
        throw new Error();
    }

    bridges.configuredBridges.forEach((item: BridgeConfig) => {
        if (!routingContractsMap[item.source]) {
            routingContractsMap[item.source] = {};
        }
        routingContractsMap[item.source][item.destination] = item.addresses;
    });

    // Add routingContractsMap variable
    sourceFile.addVariableStatement({
        declarationKind: VariableDeclarationKind.Const,
        declarations: [
            {
                name: 'routingContractsMap',
                type: 'RoutingMap',
                initializer: _formatObjectToTsLiteral(routingContractsMap),
            },
        ],
        isExported: true,
    });

    logger.info(`Configured ${bridges.configuredBridges.length} bridges.`);
    return sourceFile;
}

const _formatObjectToTsLiteral = (obj: RoutingMap): string => {
    const formatValue = (value: any): string => {
        if (typeof value === 'string') {
            return `"${value}"`;
        }
        if (typeof value === 'number' || typeof value === 'boolean' || value === null) {
            return String(value);
        }
        if (Array.isArray(value)) {
            return `[${value.map(formatValue).join(', ')}]`;
        }
        if (typeof value === 'object') {
            return _formatObjectToTsLiteral(value);
        }
        return 'undefined';
    };

    if (Array.isArray(obj)) {
        return `[${obj.map(formatValue).join(', ')}]`;
    }

    const entries = Object.entries(obj);
    const formattedEntries = entries.map(([key, value]) => `${key}: ${formatValue(value)}`);

    return `{${formattedEntries.join(', ')}}`;
};
