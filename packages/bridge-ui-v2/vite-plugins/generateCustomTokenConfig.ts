import { promises as fs } from 'fs';
import path from 'path';
import { Project, VariableDeclarationKind } from 'ts-morph';

import type { Token } from "../src/libs/token/types";
import { formatSourceFile } from './utils/formatSourceFile';
import { Logger } from './utils/Logger';

const currentDir = path.resolve(new URL(import.meta.url).pathname);
const outputPath = path.join(path.dirname(currentDir), '../src/generated/customTokenConfig.ts');

const configuredTokenConfigFile = path.join(path.dirname(currentDir), '../config', 'configuredCustomToken.json');

const pluginName = 'generateTokens';
const logger = new Logger(pluginName);

export function generateCustomTokenConfig() {
    return {
        name: pluginName,
        async buildStart() {
            logger.info('Plugin initialized.');

            // Read tokens from JSON file
            const tokenJsonContent = await fs.readFile(configuredTokenConfigFile, 'utf-8');
            const tokens: Token[] = JSON.parse(tokenJsonContent);

            const tsFilePath = path.resolve(outputPath);

            const project = new Project();
            const notification = `// Generated by ${pluginName} on ${new Date().toLocaleString()}`;
            const warning = `// WARNING: Do not change this file manually as it will be overwritten`;

            const sourceFile = project.createSourceFile(tsFilePath, `${notification}\n${warning}\n`, { overwrite: true });


            sourceFile.addImportDeclaration({
                namedImports: ['Token'],
                moduleSpecifier: '$libs/token',
                isTypeOnly: true,
            });

            sourceFile.addImportDeclaration({
                namedImports: ['TokenType'],
                moduleSpecifier: '$libs/token',
            });

            sourceFile.addVariableStatement({
                declarationKind: VariableDeclarationKind.Const,
                declarations: [
                    {
                        name: 'customToken',
                        initializer: _formatObjectToTsLiteral(tokens),
                        type: 'Token[]',
                    },
                ],
                isExported: true,
            });

            await sourceFile.save();

            const formatted = await formatSourceFile(tsFilePath)

            // Write the formatted code back to the file
            await fs.writeFile(tsFilePath, formatted);
            logger.info(`Formatted config file saved to ${tsFilePath}`);
        },
    };
}

const _formatObjectToTsLiteral = (tokens: Token[]): string => {
    const formatToken = (token: Token): string => {
        const entries = Object.entries(token);
        const formattedEntries = entries.map(([key, value]) => {
            if (key === 'type' && typeof value === 'string') {
                return `${key}: TokenType.${value}`;
            }
            if (typeof value === 'object') {
                return `${key}: ${JSON.stringify(value)}`;
            }
            return `${key}: ${JSON.stringify(value)}`;
        });

        return `{${formattedEntries.join(', ')}}`;
    };

    return `[${tokens.map(formatToken).join(', ')}]`;
};